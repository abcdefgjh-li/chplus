# .ch 文件中文解释器UI（解释器源代码闭源）

## 项目简介

这是一个使用 C++ 实现的 `.ch` 文件中文解释器，直接解析并执行 `.ch` 后缀文件，无需转换为其他语言。解释器采用类 C++ 的编译解析逻辑，所有关键字均使用中文，支持变量定义、函数定义、基本运算、控制台输出、数组操作、结构体、文件操作和流程控制等核心功能。

## 主要功能

- 完整的错误定位系统，所有错误都包含精确的行号信息
- 智能类型系统：整型运算返回整型，浮点数运算返回浮点数
- 一元负号运算符支持
- 函数作用域链支持
- 控制台输入支持（包括数组元素）
- 嵌套if语句支持
- 主函数定义语法支持
- 复合赋值运算符（+=, -=, *=, /=, %=, ^=）
- 自增自减运算符（前缀++x, --x，后置x++, x--）
- 二进制运算符（&, |, ^, ~, <<, >>）
- 复合二进制赋值运算符（&=, |=, ^=, <<=, >>=）
- 多变量定义、输入、输出功能
- 空定义功能和完整类型推断系统
- 完整的表达式评估和代码生成
- 多维数组支持：支持1-5维数组
- 动态数组大小支持：支持使用变量和表达式作为数组大小
- 文件读写操作：支持文件读取、写入和追加操作
- 结构体定义和成员访问：支持结构体定义、变量实例化和成员访问
- 函数重载：支持同名函数不同参数
- 函数返回类型检查：确保函数返回类型与定义一致
- 完整的流程控制：if-else if-else、while、for循环
- 循环控制语句：退出循环（break）、下一层循环（continue）
- ASCII字符兼容：完全支持ASCII码表和中文字符
- 系统命令行：支持系统命令行执行功能
- 跨平台兼容：支持Windows和Linux系统
- 文件内存存储：支持将变量存储到文件中，实现数据持久化和跨程序共享
- 纯内存存储：支持使用纯内存存储变量，不生成txt文件，支持大数组
- 高精度整数计算：使用BigInt实现任意长度整数运算，支持超大数计算

**Bug反馈**：有bug请tg @abcdefgjha反馈

## 开源协议

本项目采用 **GNU Affero General Public License v3.0 (AGPL v3.0) + Commons Clause 1.0** 协议。

### 核心许可声明

1. 本项目**仅允许个人非商业用途使用**，禁止任何形式的商业使用（包括但不限于：出售、出租、作为商业产品的组件、通过本项目获取商业收益等）。
2. 个人使用者可以自由修改、重构本项目代码，但修改后的衍生作品必须：
   - 遵守本许可证的全部条款（同样禁止商用）
   - 保留原项目的版权信息和许可证文本
   - 以相同的协议开源发布，且必须附带完整的源代码（包括修改记录）
   - 明确标注衍生作品与原项目的差异，并提供原项目的官方源库链接
3. 禁止删除、修改本许可证中的任何条款，禁止隐瞒原项目的作者信息和源库地址。

完整协议文本请查看 [LICENSE](LICENSE) 文件。

## 目录结构

```
chplus/
├── main.cpp              # 主程序入口
├── README.md             # 项目文档
├── LICENSE               # 开源协议
├── core/                 # 核心代码目录
│   ├── lexer.h           # 词法分析器头文件
│   ├── lexer.cpp         # 词法分析器实现
│   ├── parser.h          # 语法分析器头文件
│   ├── parser.cpp        # 语法分析器实现
│   ├── interpreter.h     # 执行器头文件
│   ├── interpreter.cpp   # 执行器实现
│   ├── FileMemory.h      # 文件内存存储头文件
│   ├── FileMemory.cpp    # 文件内存存储实现
│   ├── MemoryStorage.h   # 纯内存存储头文件
│   ├── MemoryStorage.cpp # 纯内存存储实现
│   ├── BigInt.h         # 高精度整数头文件
│   ├── BigInt.cpp       # 高精度整数实现
│   ├── CHFormatter.h     # 中文格式化器头文件
│   ├── CHFormatter.cpp   # 中文格式化器实现
│   ├── CodeFormatter.h   # 代码格式化器头文件
│   ├── CodeFormatter.cpp # 代码格式化器实现
│   └── common.h          # 公共头文件
├── jni/                  # Android JNI 构建配置
│   ├── Android.mk
│   └── Application.mk
├── examples/             # 示例文件目录
│   ├── hello.ch          # Hello World 示例
│   ├── array_demo.ch     # 数组操作示例
│   ├── bigint_demo.ch    # 高精度整数和大数组示例
│   ├── calculator.ch     # 计算器示例
│   ├── conditions.ch     # 条件语句示例
│   ├── function_overload.ch # 函数重载示例
│   ├── logic_operators.ch # 逻辑运算符示例
│   ├── binary_operators.ch # 二进制运算符示例
│   ├── file_demo.ch      # 文件操作示例
│   ├── struct_demo.ch    # 结构体示例
│   ├── struct_array_test.ch # 结构体数组测试
│   ├── minimal_struct_array.ch # 最小结构体数组示例
│   ├── scope_test.ch     # 作用域测试
│   ├── minimal_test.ch   # 最小测试
│   ├── type_conversion.ch # 类型转换示例
│   ├── unformatted_test.ch # 未格式化测试
│   ├── debug_test.ch     # 调试测试示例
│   └── bitwise_not_test.ch # 按位非运算符测试
└── ch_Lib/               # 标准库目录
    ├── math.ch           # 数学库
    ├── string.ch         # 字符串库
    ├── file.ch           # 文件库
    ├── readme.math.ch.md # 数学库文档
    ├── readme.string.ch.md # 字符串库文档
    └── readme.file.ch.md # 文件库文档
```

## 编译方法

### Windows平台编译

```bash
# 使用 g++ 编译
g++ -std=c++17 -I. main.cpp core/*.cpp -o chplus.exe
```

### Linux/Mac平台编译

```bash
# 使用 g++ 编译
g++ -std=c++17 -I. main.cpp core/*.cpp -o chplus
```

## 使用方法

### 基本使用

```bash
# 直接执行.ch文件
chplus example.ch
```

### 代码格式化

```bash
# 自动格式化并覆盖原文件
chplus -a example.ch

# 不自动格式化
chplus -n example.ch

# 启用调试模式
chplus -d example.ch
```

### 文件内存存储

```bash
# 使用文件内存存储（执行后自动删除memory.txt）
chplus -t example.ch

# 使用文件内存存储并保留文件
chplus -t reserve example.ch

# 使用纯内存存储（不生成txt文件，支持大数组）
chplus -t memory example.ch
```

**数组大小限制说明：**
- 默认情况下（不使用 -t 参数）：数组维度大小最大允许 1000
- 使用 `-t memory` 参数：支持大数组，无大小限制
- 如果数组大小超过 1000，请使用 `-t memory` 参数运行程序

## 语法说明

### 变量定义

```ch
// 带类型的变量定义
定义(整型) 数值一 = 10;
定义(字符串) 文本 = "测试内容";
定义(小数) 圆周率 = 3.14;
定义(布尔型) 是否激活 = 真;
定义(字符型) 字符 = 'A';

// 空定义（自动推断类型）
定义 数字一 = 1233;           // 自动推断为整型
定义 数字二 = 3.14;           // 自动推断为小数
定义 字符串一 = "Hello";        // 自动推断为字符串
定义 布尔值 = 真;             // 自动推断为布尔型
定义 字符一 = 'A';            // 自动推断为字符型

// 多变量定义（一次性定义多个变量）
定义(整型) 数值一 = 1, 数值二 = 2, 数值三 = 3;
定义(字符串) 姓名 = "张三", 年龄 = "25", 城市 = "北京";

// 空定义支持表达式类型推断
定义 结果一 = 数值一 + 10;         // 推断为整型（整型 + 整型）
定义 结果二 = 数字二 * 2.5;        // 推断为小数（小数 * 小数）
定义 结果三 = 数值一 > 1000;       // 推断为布尔型（比较运算）
定义 结果四 = !布尔值;             // 推断为布尔型（逻辑非）
定义 结果五 = 数值一 + 数字二;          // 推断为小数（整型 + 小数）

// 数组定义
定义(整型) 数组[10];
定义(整型) 矩阵[3][4];

// 复合赋值运算符
定义(整型) 数值 = 10;
数值 += 5;        // 数值 = 数值 + 5，结果为15
数值 -= 3;        // 数值 = 数值 - 3，结果为12
数值 *= 2;        // 数值 = 数值 * 2，结果为24
数值 /= 4;        // 数值 = 数值 / 4，结果为6
数值 %= 4;        // 数值 = 数值 % 4，结果为2
数值 ^= 2;        // 数值 = 数值 ^ 2，结果为4（2的2次方）

// 自增自减运算符（前缀）
定义(整型) 变量一 = 5;
++变量一;           // 先增加1，变量一变为6，返回6
--变量一;           // 先减少1，变量一变为5，返回5

// 自增自减运算符（后置）
定义(整型) 变量二 = 5;
变量二++;           // 返回5，然后变量二变为6
变量二--;           // 返回6，然后变量二变为5

// 自增自减用于表达式
定义(整型) 新值 = ++变量一;  // 变量一增加1，返回新值
定义(整型) 旧值 = 变量二++;     // 返回原值，变量二增加1

// 二进制运算符
定义(整型) 数值一 = 12;  // 二进制: 1100
定义(整型) 数值二 = 5;   // 二进制: 0101
定义(整型) 按位与结果 = 数值一 & 数值二;    // 1100 & 0101 = 0100 (4)
定义(整型) 按位或结果 = 数值一 | 数值二;     // 1100 | 0101 = 1101 (13)
定义(整型) 按位异或结果 = 数值一 ^ 数值二;   // 1100 ^ 0101 = 1001 (9)
定义(整型) 按位非结果 = ~数值一;             // ~1100 = 11111111111111111111111111110011 (-13)
定义(整型) 左移结果 = 数值一 << 2;           // 1100 << 2 = 110000 (48)
定义(整型) 右移结果 = 数值一 >> 1;           // 1100 >> 1 = 0110 (6)

// 复合二进制赋值运算符
定义(整型) 复合变量 = 15;  // 二进制: 1111
复合变量 &= 3;             // 1111 & 0011 = 0011 (3)
复合变量 |= 8;             // 0011 | 1000 = 1011 (11)
复合变量 ^= 5;             // 1011 ^ 0101 = 1110 (14)
复合变量 <<= 1;            // 1110 << 1 = 11100 (28)
复合变量 >>= 2;            // 11100 >> 2 = 111 (7)
```

**空定义规则：**
- 空定义语法：`定义 变量名 = 值;`
- 必须进行赋值，不能省略初始值
- 根据赋值表达式自动推断变量类型
- 支持字面量、表达式、函数调用等多种初始化方式
- 算术运算符（+、-、*、/、%）：如果有一个操作数是小数，结果就是小数
- 二进制运算符（&、|、^、~、<<、>>）：按位与、按位或、按位异或、按位非、左移、右移
- 比较运算符（==、!=、<、<=、>、>=）：结果总是布尔型
- 逻辑运算符（&&、||、!）：结果总是布尔型
- 多变量定义语法：`定义(类型) 变量1=值1, 变量2=值2, 变量3=值3;`

### 函数定义

```ch
定义(空类型) 主函数() {
    控制台输出("Hello World");
}

定义(整型) 求和(定义(整型) 数值一, 定义(整型) 数值二) {
    返回 数值一 + 数值二;
}
```

### 流程控制

```ch
如果 (条件) {
    // 条件为真时执行
} 否则如果 (其他条件) {
    // 第一个条件为假，其他条件为真时执行
} 否则 {
    // 所有条件为假时执行
}

对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    // 循环体
}

当 (条件) {
    // 循环体
}

// 退出循环：立即退出当前循环
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    如果 (索引 == 5) {
        退出循环;
    }
    控制台输出(索引);
}

// 下一层循环：跳过当前循环的剩余部分，进入下一次迭代
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    如果 (索引 == 5) {
        下一层循环;
    }
    控制台输出(索引);
}
```

### 控制台输入输出

```ch
// 单个变量输出
控制台输出("Hello World");

// 多个变量输出（一次性输出多个值）
控制台输出("a=", 数值一, " b=", 数值二, " c=", 数值三);

// 单个变量输入
控制台输入(变量);

// 多个变量输入（一次性读取多个输入值）
控制台输入(变量一, 变量二, 变量三);

文件写入("file.txt", "内容");
文件读取("file.txt", 变量);
文件追加("file.txt", "追加内容");
```

### 结构体

```ch
定义(结构体) 点 {
    整型 x;
    整型 y;
};

定义(点) 点一;
点一.x = 10;
点一.y = 20;
```

### 模块化编程

```ch
导入("ch_Lib/math.ch");
导入("ch_Lib/string.ch");
导入("ch_Lib/file.ch");

定义(空类型) 主函数() {
    定义(小数) 结果 = sin(30);
    定义(整型) 长度 = 长度("Hello");
    写入文件("output.txt", "内容");
}
```

### 系统命令行

```ch
系统命令行("echo Hello");
系统命令行("dir");
```

### 循环控制语句

CH+语言提供了两个循环控制语句：`退出循环`和`下一层循环`。

#### 退出循环（break）

`退出循环`语句用于立即终止当前循环（for循环或while循环），并跳出循环体继续执行循环之后的代码。

```ch
// 在for循环中使用退出循环
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引 = 索引 + 1) {
    如果 (索引 == 5) {
        退出循环;  // 当索引等于5时退出循环
    }
    控制台输出(索引);  // 输出: 0, 1, 2, 3, 4
}

// 在while循环中使用退出循环
定义(整型) 变量一 = 0;
当 (变量一 < 10) {
    如果 (变量一 == 5) {
        退出循环;  // 当变量一等于5时退出循环
    }
    控制台输出(变量一);  // 输出: 0, 1, 2, 3, 4
    变量一 = 变量一 + 1;
}
```

#### 下一层循环（continue）

`下一层循环`语句用于跳过当前循环的剩余部分，直接进入下一次迭代。

```ch
// 在for循环中使用下一层循环
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引 = 索引 + 1) {
    如果 (索引 == 5) {
        下一层循环;  // 当索引等于5时跳过本次迭代
    }
    控制台输出(索引);  // 输出: 0, 1, 2, 3, 4, 6, 7, 8, 9
}

// 在while循环中使用下一层循环
定义(整型) 变量二 = 0;
当 (变量二 < 10) {
    变量二 = 变量二 + 1;
    如果 (变量二 == 5) {
        下一层循环;  // 当变量二等于5时跳过本次迭代
    }
    控制台输出(变量二);  // 输出: 1, 2, 3, 4, 6, 7, 8, 9, 10
}
```

#### 嵌套循环中的使用

在嵌套循环中，`退出循环`和`下一层循环`只影响当前层级的循环。

```ch
// 嵌套循环中的退出循环
对于 (定义(整型) 索引一 = 0; 索引一 < 3; 索引一 = 索引一 + 1) {
    对于 (定义(整型) 索引二 = 0; 索引二 < 3; 索引二 = 索引二 + 1) {
        如果 (索引一 == 1 && 索引二 == 1) {
            退出循环;  // 只退出内层循环
        }
        控制台输出("i=" + 索引一 + ", j=" + 索引二);
    }
}

// 嵌套循环中的下一层循环
对于 (定义(整型) 索引一 = 0; 索引一 < 3; 索引一 = 索引一 + 1) {
    对于 (定义(整型) 索引二 = 0; 索引二 < 3; 索引二 = 索引二 + 1) {
        如果 (索引二 == 1) {
            下一层循环;  // 只跳过内层循环的当前迭代
        }
        控制台输出("i=" + 索引一 + ", j=" + 索引二);
    }
}
```

#### 使用注意事项

- `退出循环`和`下一层循环`只能用于for循环和while循环内部
- 在嵌套循环中，它们只影响当前层级的循环
