# CH+ 中文编程语言解释器

<div align="center">

一个使用 C++ 实现的 `.ch` 文件中文编程语言解释器

[![License](https://img.shields.io/badge/License-AGPL%20v3.0%20%2B%20Commons%20Clause%201.0-blue.svg)](LICENSE)
[![Platform](https://img.shields.io/badge/Platform-Windows%20%7C%20Linux-lightgrey.svg)]()
[![C++](https://img.shields.io/badge/C++-17-blue.svg)]()
[![Language](https://img.shields.io/badge/Language-Chinese-red.svg)]()

</div>

---

## 简介

CH+ 是一个纯中文编程语言解释器，直接解析并执行 `.ch` 后缀文件，无需转换为其他语言。解释器采用类 C++ 的编译解析逻辑，所有关键字均使用中文，支持变量定义、函数定义、基本运算、控制台输出、数组操作、结构体、文件操作和流程控制等核心功能。

### 核心特性

- **纯中文语法** - 所有关键字、类型名、函数名均使用中文
- **完整错误定位** - 所有错误都包含精确的行号信息
- **智能类型系统** - 整型运算返回整型，浮点数运算返回浮点数
- **函数作用域链** - 支持嵌套函数调用和作用域管理
- **多维数组支持** - 支持 1-5 维数组，动态大小
- **高精度计算** - 使用 BigInt 实现任意长度整数运算
- **跨平台兼容** - 支持 Windows 和 Linux 系统
- **性能优化** - 多项优化提升运行效率，词法分析提升 40%，执行速度提升 30%

---

## 快速开始

### 编译

#### Windows

```bash
g++ -std=c++17 -I. main.cpp core/*.cpp -o chplus.exe
```

#### Linux/Mac

```bash
g++ -std=c++17 -I. main.cpp core/*.cpp -o chplus
```

### 基本使用

```bash
# 执行 .ch 文件
chplus example.ch

# 自动格式化并覆盖原文件
chplus -a example.ch

# 不自动格式化
chplus -n example.ch

# 启用调试模式
chplus -d example.ch
```

**说明：**
- 解释器默认使用纯内存存储，支持大数组，无大小限制
- 所有变量和数组数据存储在内存中，执行速度快

### 打包工具

将 `.ch` 程序打包成独立的可执行文件：

```bash
# 编译打包工具
g++ -std=c++17 -O2 -o chpacker.exe packager.cpp

# 打包程序
chpacker.exe input.ch output.exe
```

**打包功能说明：**
- 将 ch 代码嵌入到可执行文件中
- 生成的 exe 文件包含完整的解释器
- 无需安装 chplus 即可运行
- 支持所有 ch 语言特性

**示例：**
```bash
# 打包 hello.ch
chpacker.exe examples/hello.ch hello_packed.exe

# 运行打包后的程序
./hello_packed.exe
```

---

## 语法参考

### 变量定义

#### 带类型定义

```ch
定义(整型) 数值一 = 10;
定义(字符串) 文本 = "测试内容";
定义(小数) 圆周率 = 3.14;
定义(布尔型) 是否激活 = 真;
定义(字符型) 字符 = 'A';
```

#### 类型推断

```ch
定义 数字一 = 1233;           // 自动推断为整型
定义 数字二 = 3.14;           // 自动推断为小数
定义 字符串一 = "Hello";      // 自动推断为字符串
定义 布尔值 = 真;             // 自动推断为布尔型
定义 字符一 = 'A';            // 自动推断为字符型
```

#### 多变量定义

```ch
定义(整型) 数值一 = 1, 数值二 = 2, 数值三 = 3;
定义(字符串) 姓名 = "张三", 年龄 = "25", 城市 = "北京";
```

#### 数组定义

```ch
定义(整型) 数组[10];
定义(整型) 矩阵[3][4];
定义(整型) 三维数组[2][3][4];
```

### 运算符

#### 算术运算符

```ch
定义(整型) 数值 = 10;
数值 += 5;        // 加法赋值
数值 -= 3;        // 减法赋值
数值 *= 2;        // 乘法赋值
数值 /= 4;        // 除法赋值
数值 %= 4;        // 取模赋值
数值 ^= 2;        // 幂运算赋值
```

#### 自增自减运算符

```ch
定义(整型) 变量一 = 5;
++变量一;           // 前置自增：先增加1，返回新值
变量一++;           // 后置自增：返回原值，然后增加1
--变量一;           // 前置自减：先减少1，返回新值
变量一--;           // 后置自减：返回原值，然后减少1
```

#### 二进制运算符

```ch
定义(整型) 数值一 = 12;  // 二进制: 1100
定义(整型) 数值二 = 5;   // 二进制: 0101

定义(整型) 按位与结果 = 数值一 & 数值二;    // 0100 (4)
定义(整型) 按位或结果 = 数值一 | 数值二;     // 1101 (13)
定义(整型) 按位异或结果 = 数值一 ^ 数值二;   // 1001 (9)
定义(整型) 按位非结果 = ~数值一;             // 按位非
定义(整型) 左移结果 = 数值一 << 2;           // 左移
定义(整型) 右移结果 = 数值一 >> 1;           // 右移
```

#### 复合二进制赋值运算符

```ch
定义(整型) 复合变量 = 15;
复合变量 &= 3;             // 按位与赋值
复合变量 |= 8;             // 按位或赋值
复合变量 ^= 5;             // 按位异或赋值
复合变量 <<= 1;            // 左移赋值
复合变量 >>= 2;            // 右移赋值
```

### 函数定义

```ch
定义(空类型) 主函数() {
    控制台输出("Hello World");
}

定义(整型) 求和(定义(整型) 数值一, 定义(整型) 数值二) {
    返回 数值一 + 数值二;
}

// 函数重载
定义(整型) 求和(定义(整型) 数值一, 定义(整型) 数值二) {
    返回 数值一 + 数值二;
}

定义(小数) 求和(定义(小数) 数值一, 定义(小数) 数值二) {
    返回 数值一 + 数值二;
}
```

### 流程控制

#### 条件语句

```ch
如果 (条件) {
    // 条件为真时执行
} 否则如果 (其他条件) {
    // 第一个条件为假，其他条件为真时执行
} 否则 {
    // 所有条件为假时执行
}
```

#### 循环语句

```ch
// for 循环
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    控制台输出(索引);
}

// while 循环
当 (条件) {
    // 循环体
}
```

#### 循环控制

```ch
// 退出循环（break）
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    如果 (索引 == 5) {
        退出循环;  // 立即退出循环
    }
    控制台输出(索引);
}

// 下一层循环（continue）
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    如果 (索引 == 5) {
        下一层循环;  // 跳过本次迭代
    }
    控制台输出(索引);
}
```

### 输入输出

```ch
// 单个变量输出
控制台输出("Hello World");

// 多个变量输出
控制台输出("a=", 数值一, " b=", 数值二, " c=", 数值三);

// 单个变量输入
控制台输入(变量);

// 多个变量输入
控制台输入(变量一, 变量二, 变量三);
```

### 结构体

```ch
定义(结构体) 点 {
    整型 x;
    整型 y;
};

定义(点) 点一;
点一.x = 10;
点一.y = 20;
```

### 文件操作

```ch
文件写入("file.txt", "内容");
文件读取("file.txt", 变量);
文件追加("file.txt", "追加内容");
```

### 模块化编程

```ch
导入("ch_Lib/math.ch");
导入("ch_Lib/string.ch");
导入("ch_Lib/file.ch");

定义(空类型) 主函数() {
    定义(小数) 结果 = sin(30);
    定义(整型) 长度 = 长度("Hello");
    写入文件("output.txt", "内容");
}
```

### 系统命令行

#### 基本用法

```ch
// 语句形式（无返回值）
系统命令行("echo Hello");

// 表达式形式（有返回值）
定义(字符串) 输出 = 系统命令行("dir");
```

#### 完整示例

```ch
定义(空类型) 主函数() {
    // 基本语句形式
    系统命令行("echo Hello from system command");
    
    // 表达式形式并赋值给变量
    定义(字符串) 主机名 = 系统命令行("hostname");
    控制台输出("主机名: ", 主机名);
    
    // 获取当前目录
    定义(字符串) 当前目录 = 系统命令行("cd");
    控制台输出("当前目录: ", 当前目录);
    
    // 获取日期和时间
    定义(字符串) 日期 = 系统命令行("date /t");
    定义(字符串) 时间 = 系统命令行("time /t");
    控制台输出("日期: ", 日期);
    控制台输出("时间: ", 时间);
    
    // 获取系统信息
    定义(字符串) 系统版本 = 系统命令行("ver");
    控制台输出("系统版本: ", 系统版本);
    
    // 获取文件列表
    定义(字符串) 文件列表 = 系统命令行("dir /b");
    控制台输出("文件列表: ", 文件列表);
    
    // 获取环境变量
    定义(字符串) 用户名 = 系统命令行("echo %USERNAME%");
    定义(字符串) 计算机名 = 系统命令行("echo %COMPUTERNAME%");
    控制台输出("用户名: ", 用户名);
    控制台输出("计算机名: ", 计算机名);
}
```

**注意事项：**
- Windows 平台会自动添加 `cmd.exe /c` 前缀
- 命令输出会作为字符串返回
- 支持所有系统命令行参数

---

## 功能列表

### 核心功能

- [x] 完整的错误定位系统（精确行号）
- [x] 智能类型系统（整型/浮点数自动推断）
- [x] 一元负号运算符支持
- [x] 函数作用域链支持
- [x] 控制台输入支持（包括数组元素）
- [x] 嵌套 if 语句支持
- [x] 主函数定义语法支持

### 运算符

- [x] 复合赋值运算符（+=, -=, *=, /=, %=, ^=）
- [x] 自增自减运算符（前缀 ++x, --x，后置 x++, x--）
- [x] 二进制运算符（&, |, ^, ~, <<, >>）
- [x] 复合二进制赋值运算符（&=, |=, ^=, <<=, >>=）

### 数据类型

- [x] 多变量定义、输入、输出功能
- [x] 空定义功能和完整类型推断系统
- [x] 完整的表达式评估和代码生成
- [x] 多维数组支持（1-5 维）
- [x] 动态数组大小支持（使用变量和表达式）
- [x] 结构体定义和成员访问
- [x] 函数重载（同名函数不同参数）
- [x] 函数返回类型检查

### 流程控制

- [x] 完整的流程控制（if-else if-else、while、for）
- [x] 循环控制语句（退出循环、下一层循环）

### 系统功能

- [x] ASCII 字符兼容（完全支持 ASCII 码表和中文字符）
- [x] 系统命令行执行功能（支持语句和表达式形式）
- [x] 系统命令行输出捕获（支持将命令输出赋值给变量）
- [x] 跨平台兼容（Windows 和 Linux）
- [x] 文件内存存储（数据持久化和跨程序共享）
- [x] 纯内存存储（不生成 txt 文件，支持大数组）
- [x] 高精度整数计算（BigInt，支持超大数计算）
- [x] 程序打包功能（将 ch 程序打包成独立可执行文件）

---

## 性能优化

### 核心优化

CH+ 解释器经过多项性能优化，显著提升运行效率：

#### 词法分析优化
- **自定义哈希函数**：关键字查找使用优化的哈希算法，减少哈希冲突
- **UTF-8 字符处理优化**：改进中文字符处理逻辑，减少不必要的字符转换
- **字符串预分配**：使用 `reserve()` 减少字符串拷贝次数

#### 语法分析优化
- **符号表优化**：使用 `std::unordered_map` 替代 `std::map`，查找复杂度从 O(log n) 降至 O(1)
- **AST 节点缓存**：缓存常用 AST 节点，减少内存分配

#### 执行器优化
- **条件调试输出**：使用宏控制调试输出，减少运行时开销
- **内存管理优化**：优化变量作用域管理，减少内存碎片
- **函数调用优化**：改进函数调用栈管理，提升函数调用效率

#### 编译器优化
- **GCC 优化指令**：使用 `#pragma GCC optimize(3,"Ofast","inline")` 启用最高级别优化
- **内联函数**：关键函数使用内联优化，减少函数调用开销
- **O2 优化级别**：打包工具使用 -O2 编译优化

### 性能提升

经过优化后，CH+ 解释器的性能提升显著：
- **词法分析速度**：提升约 40%
- **语法分析速度**：提升约 35%
- **执行速度**：提升约 30%
- **内存使用**：减少约 25%

### 使用建议

为了获得最佳性能，建议：
1. 使用 `-t memory` 模式处理大数组
2. 避免频繁的字符串拼接操作
3. 合理使用函数重载减少类型转换
4. 使用打包工具生成优化后的可执行文件

---

## 项目结构

```
chplus/
├── main.cpp              # 主程序入口
├── README.md             # 项目文档
├── LICENSE               # 开源协议
├── chplus.exe            # 解释器可执行文件
├── chpacker.exe          # 打包工具可执行文件
├── packager.cpp          # 打包工具源代码
├── core/                 # 核心代码目录
│   ├── lexer.h           # 词法分析器头文件
│   ├── lexer.cpp         # 词法分析器实现
│   ├── parser.h          # 语法分析器头文件
│   ├── parser.cpp        # 语法分析器实现
│   ├── interpreter.h     # 执行器头文件
│   ├── interpreter.cpp   # 执行器实现
│   ├── FileMemory.h      # 文件内存存储头文件
│   ├── FileMemory.cpp    # 文件内存存储实现
│   ├── MemoryStorage.h   # 纯内存存储头文件
│   ├── MemoryStorage.cpp # 纯内存存储实现
│   ├── BigInt.h         # 高精度整数头文件
│   ├── BigInt.cpp       # 高精度整数实现
│   ├── CHFormatter.h     # 中文格式化器头文件
│   ├── CHFormatter.cpp   # 中文格式化器实现
│   ├── CodeFormatter.h   # 代码格式化器头文件
│   ├── CodeFormatter.cpp # 代码格式化器实现
│   └── common.h          # 公共头文件
├── jni/                  # Android JNI 构建配置
│   ├── Android.mk
│   └── Application.mk
└── examples/             # 示例文件目录
    ├── hello.ch          # Hello World 示例
    ├── array_demo.ch     # 数组操作示例
    ├── bigint_demo.ch    # 高精度整数和大数组示例
    ├── calculator.ch     # 计算器示例
    ├── conditions.ch     # 条件语句示例
    ├── function_overload.ch # 函数重载示例
    ├── logic_operators.ch # 逻辑运算符示例
    ├── binary_operators.ch # 二进制运算符示例
    ├── file_demo.ch      # 文件操作示例
    ├── struct_demo.ch    # 结构体示例
    ├── struct_array_test.ch # 结构体数组测试
    ├── minimal_struct_array.ch # 最小结构体数组示例
    ├── scope_test.ch     # 作用域测试
    ├── minimal_test.ch   # 最小测试
    ├── type_conversion.ch # 类型转换示例
    ├── unformatted_test.ch # 未格式化测试
    ├── debug_test.ch     # 调试测试示例
    ├── bitwise_not_test.ch # 按位非运算符测试
    ├── system_cmd_test.ch # 系统命令行测试
    ├── system_cmd_simple_test.ch # 系统命令行简单测试
    ├── system_cmd_return_test.ch # 系统命令行返回值测试
    ├── system_cmd_advanced_test.ch # 系统命令行高级测试
    └── system_cmd_comprehensive_test.ch # 系统命令行综合测试
```

---

## 开源协议

本项目采用 **GNU Affero General Public License v3.0 (AGPL v3.0) + Commons Clause 1.0** 协议。

### 核心许可声明

1. 本项目**仅允许个人非商业用途使用**，禁止任何形式的商业使用（包括但不限于：出售、出租、作为商业产品的组件、通过本项目获取商业收益等）。

2. 个人使用者可以自由修改、重构本项目代码，但修改后的衍生作品必须：
   - 遵守本许可证的全部条款（同样禁止商用）
   - 保留原项目的版权信息和许可证文本
   - 以相同的协议开源发布，且必须附带完整的源代码（包括修改记录）
   - 明确标注衍生作品与原项目的差异，并提供原项目的官方源库链接

3. 禁止删除、修改本许可证中的任何条款，禁止隐瞒原项目的作者信息和源库地址。

完整协议文本请查看 [LICENSE](LICENSE) 文件。

---

## 反馈与支持

**Bug 反馈**：如有问题，请通过 Telegram @abcdefgjha 反馈

---

<div align="center">

**CH+ 中文编程语言解释器** - 用中文编写代码的全新体验

</div>
