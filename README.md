# .ch 文件中文解释器

## 项目简介

这是一个使用 C++ 实现的 `.ch` 文件中文解释器，直接解析并执行 `.ch` 后缀文件，无需转换为其他语言。解释器采用类 C++ 的编译解析逻辑，所有关键字均使用中文，支持变量定义、函数定义、基本运算、控制台输出、数组操作、结构体、文件操作和流程控制等核心功能。

## 主要功能

- 完整的错误定位系统，所有错误都包含精确的行号信息
- 智能类型系统：整型运算返回整型，浮点数运算返回浮点数
- 一元负号运算符支持
- 函数作用域链支持
- 控制台输入支持（包括数组元素）
- 嵌套if语句支持
- 主函数定义语法支持
- 复合赋值运算符（+=, -=, *=, /=, %=, ^=）
- 自增自减运算符（前缀++x, --x，后置x++, x--）
- 二进制运算符（&, |, ^, ~, <<, >>）
- 复合二进制赋值运算符（&=, |=, ^=, <<=, >>=）
- 多变量定义、输入、输出功能
- 空定义功能和完整类型推断系统
- 完整的表达式评估和代码生成
- 多维数组支持：支持1-5维数组
- 动态数组大小支持：支持使用变量和表达式作为数组大小
- 文件读写操作：支持文件读取、写入和追加操作
- 结构体定义和成员访问：支持结构体定义、变量实例化和成员访问
- 函数重载：支持同名函数不同参数
- 函数返回类型检查：确保函数返回类型与定义一致
- 完整的流程控制：if-else if-else、while、for循环
- 循环控制语句：退出循环（break）、下一层循环（continue）
- ASCII字符兼容：完全支持ASCII码表和中文字符
- 系统命令行：支持系统命令行执行功能
- 跨平台兼容：支持Windows和Linux系统
- 文件内存存储：支持将变量存储到文件中，实现数据持久化和跨程序共享
- 纯内存存储：支持使用纯内存存储变量，不生成txt文件，支持大数组
- 高精度整数计算：使用BigInt实现任意长度整数运算，支持超大数计算

**Bug反馈**：有bug请tg @abcdefgjha反馈

## 开源协议

本项目采用 **GNU Affero General Public License v3.0 (AGPL v3.0) + Commons Clause 1.0** 协议。

### 核心许可声明

1. 本项目**仅允许个人非商业用途使用**，禁止任何形式的商业使用（包括但不限于：出售、出租、作为商业产品的组件、通过本项目获取商业收益等）。
2. 个人使用者可以自由修改、重构本项目代码，但修改后的衍生作品必须：
   - 遵守本许可证的全部条款（同样禁止商用）
   - 保留原项目的版权信息和许可证文本
   - 以相同的协议开源发布，且必须附带完整的源代码（包括修改记录）
   - 明确标注衍生作品与原项目的差异，并提供原项目的官方源库链接
3. 禁止删除、修改本许可证中的任何条款，禁止隐瞒原项目的作者信息和源库地址。

完整协议文本请查看 [LICENSE](LICENSE) 文件。

## 目录结构

```
chplus/
├── main.cpp              # 主程序入口
├── README.md             # 项目文档
├── LICENSE               # 开源协议
├── core/                 # 核心代码目录
│   ├── lexer.h           # 词法分析器头文件
│   ├── lexer.cpp         # 词法分析器实现
│   ├── parser.h          # 语法分析器头文件
│   ├── parser.cpp        # 语法分析器实现
│   ├── interpreter.h     # 执行器头文件
│   ├── interpreter.cpp   # 执行器实现
│   ├── FileMemory.h      # 文件内存存储头文件
│   ├── FileMemory.cpp    # 文件内存存储实现
│   ├── MemoryStorage.h   # 纯内存存储头文件
│   ├── MemoryStorage.cpp # 纯内存存储实现
│   ├── BigInt.h         # 高精度整数头文件
│   ├── BigInt.cpp       # 高精度整数实现
│   ├── CHFormatter.h     # 中文格式化器头文件
│   ├── CHFormatter.cpp   # 中文格式化器实现
│   ├── CodeFormatter.h   # 代码格式化器头文件
│   ├── CodeFormatter.cpp # 代码格式化器实现
│   └── common.h          # 公共头文件
├── jni/                  # Android JNI 构建配置
│   ├── Android.mk
│   └── Application.mk
├── examples/             # 示例文件目录
│   ├── hello.ch          # Hello World 示例
│   ├── array_demo.ch     # 数组操作示例
│   ├── bigint_demo.ch    # 高精度整数和大数组示例
│   ├── calculator.ch     # 计算器示例
│   ├── conditions.ch     # 条件语句示例
│   ├── function_overload.ch # 函数重载示例
│   ├── logic_operators.ch # 逻辑运算符示例
│   ├── binary_operators.ch # 二进制运算符示例
│   ├── math_demo.ch      # 数学库示例
│   ├── math_calculator.ch # 数学计算器示例
│   ├── string_basic.ch   # 字符串基础操作示例
│   ├── string_find_replace.ch # 字符串查找替换示例
│   ├── file_basic.ch     # 文件基础操作示例
│   ├── file_demo.ch      # 文件操作示例
│   ├── file_redirect.ch  # 文件重定向示例
│   ├── struct_demo.ch    # 结构体示例
│   ├── struct_array_test.ch # 结构体数组测试
│   ├── minimal_struct_array.ch # 最小结构体数组示例
│   ├── scope_test.ch     # 作用域测试
│   ├── minimal_test.ch   # 最小测试
│   ├── type_conversion.ch # 类型转换示例
│   ├── unformatted_test.ch # 未格式化测试
│   ├── debug_test.ch     # 调试测试示例
│   ├── bitwise_not_test.ch # 按位非运算符测试
│   └── palindrome.ch    # 回文检测示例
└── ch_Lib/               # 标准库目录
    ├── math.ch           # 数学库
    ├── string.ch         # 字符串库
    ├── file.ch           # 文件库
    ├── readme.math.ch.md # 数学库文档
    ├── readme.string.ch.md # 字符串库文档
    └── readme.file.ch.md # 文件库文档
```

## 编译方法

### Windows平台编译

```bash
# 使用 g++ 编译
g++ -std=c++17 -I. main.cpp core/*.cpp -o chplus.exe
```
: 应用配置，指定目标平台和编译选项

## 样例文件功能分析

项目包含24个样例文件，用于展示CH+语言的各种功能特性。基于对每个文件内容的语法分析和实际测试，以下是功能评估：

### 功能分类统计
- **总样例数**: 24个
- **语法正确可运行**: 22个 (92%)
- **需要调试修复**: 2个 (8%)

### 语法正确可运行的样例文件 (22个)
以下样例文件语法正确，功能完整，可以正常运行：

#### 基础语法示例
1. **hello.ch** - Hello World示例，展示基本程序结构
2. **calculator.ch** - 基础算术运算示例，展示变量定义和计算
3. **conditions.ch** - 条件语句示例，展示if-else if-else结构
4. **array_demo.ch** - 数组操作示例，展示数组定义、初始化和遍历
5. **bitwise_not_test.ch** - 按位非运算符测试，展示二进制运算
6. **debug_test.ch** - 调试测试示例，展示简单算术运算
7. **minimal_test.ch** - 最小测试示例，展示最简洁语法
8. **unformatted_test.ch** - 未格式化测试，展示代码格式化功能

#### 标准库功能示例
9. **file_basic.ch** - 文件操作基础示例，使用file.ch库
10. **file_demo.ch** - 文件操作示例，展示文件读写功能
11. **file_redirect.ch** - 文件重定向示例，使用file.ch库
12. **math_calculator.ch** - 数学计算器示例，使用math.ch库
13. **math_demo.ch** - 数学库示例，展示三角函数计算
14. **string_basic.ch** - 字符串基础操作示例，使用string.ch库
15. **string_find_replace.ch** - 字符串查找替换示例，使用string.ch库

#### 高级功能示例
16. **binary_operators.ch** - 二进制运算符示例，展示完整的二进制运算
17. **logic_operators.ch** - 逻辑运算符示例，展示中文逻辑运算
18. **minimal_struct_array.ch** - 最小结构体数组示例，展示结构体定义
19. **scope_test.ch** - 作用域测试，展示全局和局部变量
20. **struct_demo.ch** - 结构体示例，展示结构体成员访问
21. **struct_array_test.ch** - 结构体数组测试，展示结构体数组定义和成员访问
22. **type_conversion.ch** - 类型转换示例，展示类型转换功能

### 已修复的样例文件
23. **function_overload.ch** - 函数重载概念演示（已修复类型匹配问题）

### 需要调试的示例 (2个)
以下样例文件存在语法错误或逻辑问题，需要进一步调试：

1. **bigint_demo.ch** - 大数组测试，数组大小超出限制（需要使用 -t memory 参数）
2. **palindrome.ch** - 回文检测示例，代码逻辑不完整

## 使用方法

### 基本使用

```bash
# 直接执行.ch文件
chplus example.ch
```

### 代码格式化

```bash
# 自动格式化并覆盖原文件
chplus -a example.ch

# 不自动格式化
chplus -n example.ch

# 启用调试模式
chplus -d example.ch
```

### 文件内存存储

```bash
# 使用文件内存存储（执行后自动删除memory.txt）
chplus -t example.ch

# 使用文件内存存储并保留文件
chplus -t reserve example.ch

# 使用纯内存存储（不生成txt文件，支持大数组）
chplus -t memory example.ch
```

**数组大小限制说明：**
- 默认情况下（不使用 -t 参数）：数组维度大小最大允许 1000
- 使用 `-t memory` 参数：支持大数组，无大小限制
- 如果数组大小超过 1000，请使用 `-t memory` 参数运行程序

## 语法说明

### 变量定义

```ch
// 带类型的变量定义
定义(整型) 数值一 = 10;
定义(字符串) 文本 = "测试内容";
定义(小数) 圆周率 = 3.14;
定义(布尔型) 是否激活 = 真;
定义(字符型) 字符 = 'A';

// 空定义（自动推断类型）
定义 数字一 = 1233;           // 自动推断为整型
定义 数字二 = 3.14;           // 自动推断为小数
定义 字符串一 = "Hello";        // 自动推断为字符串
定义 布尔值 = 真;             // 自动推断为布尔型
定义 字符一 = 'A';            // 自动推断为字符型

// 多变量定义（一次性定义多个变量）
定义(整型) 数值一 = 1, 数值二 = 2, 数值三 = 3;
定义(字符串) 姓名 = "张三", 年龄 = "25", 城市 = "北京";

// 空定义支持表达式类型推断
定义 结果一 = 数值一 + 10;         // 推断为整型（整型 + 整型）
定义 结果二 = 数字二 * 2.5;        // 推断为小数（小数 * 小数）
定义 结果三 = 数值一 > 1000;       // 推断为布尔型（比较运算）
定义 结果四 = !布尔值;             // 推断为布尔型（逻辑非）
定义 结果五 = 数值一 + 数字二;          // 推断为小数（整型 + 小数）

// 数组定义
定义(整型) 数组[10];
定义(整型) 矩阵[3][4];

// 复合赋值运算符
定义(整型) 数值 = 10;
数值 += 5;        // 数值 = 数值 + 5，结果为15
数值 -= 3;        // 数值 = 数值 - 3，结果为12
数值 *= 2;        // 数值 = 数值 * 2，结果为24
数值 /= 4;        // 数值 = 数值 / 4，结果为6
数值 %= 4;        // 数值 = 数值 % 4，结果为2
数值 ^= 2;        // 数值 = 数值 ^ 2，结果为4（2的2次方）

// 自增自减运算符（前缀）
定义(整型) 变量一 = 5;
++变量一;           // 先增加1，变量一变为6，返回6
--变量一;           // 先减少1，变量一变为5，返回5

// 自增自减运算符（后置）
定义(整型) 变量二 = 5;
变量二++;           // 返回5，然后变量二变为6
变量二--;           // 返回6，然后变量二变为5

// 自增自减用于表达式
定义(整型) 新值 = ++变量一;  // 变量一增加1，返回新值
定义(整型) 旧值 = 变量二++;     // 返回原值，变量二增加1

// 二进制运算符
定义(整型) 数值一 = 12;  // 二进制: 1100
定义(整型) 数值二 = 5;   // 二进制: 0101
定义(整型) 按位与结果 = 数值一 & 数值二;    // 1100 & 0101 = 0100 (4)
定义(整型) 按位或结果 = 数值一 | 数值二;     // 1100 | 0101 = 1101 (13)
定义(整型) 按位异或结果 = 数值一 ^ 数值二;   // 1100 ^ 0101 = 1001 (9)
定义(整型) 按位非结果 = ~数值一;             // ~1100 = 11111111111111111111111111110011 (-13)
定义(整型) 左移结果 = 数值一 << 2;           // 1100 << 2 = 110000 (48)
定义(整型) 右移结果 = 数值一 >> 1;           // 1100 >> 1 = 0110 (6)

// 复合二进制赋值运算符
定义(整型) 复合变量 = 15;  // 二进制: 1111
复合变量 &= 3;             // 1111 & 0011 = 0011 (3)
复合变量 |= 8;             // 0011 | 1000 = 1011 (11)
复合变量 ^= 5;             // 1011 ^ 0101 = 1110 (14)
复合变量 <<= 1;            // 1110 << 1 = 11100 (28)
复合变量 >>= 2;            // 11100 >> 2 = 111 (7)
```

**空定义规则：**
- 空定义语法：`定义 变量名 = 值;`
- 必须进行赋值，不能省略初始值
- 根据赋值表达式自动推断变量类型
- 支持字面量、表达式、函数调用等多种初始化方式
- 算术运算符（+、-、*、/、%）：如果有一个操作数是小数，结果就是小数
- 二进制运算符（&、|、^、~、<<、>>）：按位与、按位或、按位异或、按位非、左移、右移
- 比较运算符（==、!=、<、<=、>、>=）：结果总是布尔型
- 逻辑运算符（&&、||、!）：结果总是布尔型
- 多变量定义语法：`定义(类型) 变量1=值1, 变量2=值2, 变量3=值3;`

### 函数定义

```ch
定义(空类型) 主函数() {
    控制台输出("Hello World");
}

定义(整型) 求和(定义(整型) 数值一, 定义(整型) 数值二) {
    返回 数值一 + 数值二;
}
```

### 流程控制

```ch
如果 (条件) {
    // 条件为真时执行
} 否则如果 (其他条件) {
    // 第一个条件为假，其他条件为真时执行
} 否则 {
    // 所有条件为假时执行
}

对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    // 循环体
}

当 (条件) {
    // 循环体
}

// 退出循环：立即退出当前循环
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    如果 (索引 == 5) {
        退出循环;
    }
    控制台输出(索引);
}

// 下一层循环：跳过当前循环的剩余部分，进入下一次迭代
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引++) {
    如果 (索引 == 5) {
        下一层循环;
    }
    控制台输出(索引);
}
```

### 控制台输入输出

```ch
// 单个变量输出
控制台输出("Hello World");

// 多个变量输出（一次性输出多个值）
控制台输出("a=", 数值一, " b=", 数值二, " c=", 数值三);

// 单个变量输入
控制台输入(变量);

// 多个变量输入（一次性读取多个输入值）
控制台输入(变量一, 变量二, 变量三);

文件写入("file.txt", "内容");
文件读取("file.txt", 变量);
文件追加("file.txt", "追加内容");
```

### 结构体

```ch
定义(结构体) 点 {
    整型 x;
    整型 y;
};

定义(点) 点一;
点一.x = 10;
点一.y = 20;
```

### 模块化编程

```ch
导入("ch_Lib/math.ch");
导入("ch_Lib/string.ch");
导入("ch_Lib/file.ch");

定义(空类型) 主函数() {
    定义(小数) 结果 = sin(30);
    定义(整型) 长度 = 长度("Hello");
    写入文件("output.txt", "内容");
}
```

### 系统命令行

```ch
系统命令行("echo Hello");
系统命令行("dir");
```

### 循环控制语句

CH+语言提供了两个循环控制语句：`退出循环`和`下一层循环`。

#### 退出循环（break）

`退出循环`语句用于立即终止当前循环（for循环或while循环），并跳出循环体继续执行循环之后的代码。

```ch
// 在for循环中使用退出循环
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引 = 索引 + 1) {
    如果 (索引 == 5) {
        退出循环;  // 当索引等于5时退出循环
    }
    控制台输出(索引);  // 输出: 0, 1, 2, 3, 4
}

// 在while循环中使用退出循环
定义(整型) 变量一 = 0;
当 (变量一 < 10) {
    如果 (变量一 == 5) {
        退出循环;  // 当变量一等于5时退出循环
    }
    控制台输出(变量一);  // 输出: 0, 1, 2, 3, 4
    变量一 = 变量一 + 1;
}
```

#### 下一层循环（continue）

`下一层循环`语句用于跳过当前循环的剩余部分，直接进入下一次迭代。

```ch
// 在for循环中使用下一层循环
对于 (定义(整型) 索引 = 0; 索引 < 10; 索引 = 索引 + 1) {
    如果 (索引 == 5) {
        下一层循环;  // 当索引等于5时跳过本次迭代
    }
    控制台输出(索引);  // 输出: 0, 1, 2, 3, 4, 6, 7, 8, 9
}

// 在while循环中使用下一层循环
定义(整型) 变量二 = 0;
当 (变量二 < 10) {
    变量二 = 变量二 + 1;
    如果 (变量二 == 5) {
        下一层循环;  // 当变量二等于5时跳过本次迭代
    }
    控制台输出(变量二);  // 输出: 1, 2, 3, 4, 6, 7, 8, 9, 10
}
```

#### 嵌套循环中的使用

在嵌套循环中，`退出循环`和`下一层循环`只影响当前层级的循环。

```ch
// 嵌套循环中的退出循环
对于 (定义(整型) 索引一 = 0; 索引一 < 3; 索引一 = 索引一 + 1) {
    对于 (定义(整型) 索引二 = 0; 索引二 < 3; 索引二 = 索引二 + 1) {
        如果 (索引一 == 1 && 索引二 == 1) {
            退出循环;  // 只退出内层循环
        }
        控制台输出("i=" + 索引一 + ", j=" + 索引二);
    }
}

// 嵌套循环中的下一层循环
对于 (定义(整型) 索引一 = 0; 索引一 < 3; 索引一 = 索引一 + 1) {
    对于 (定义(整型) 索引二 = 0; 索引二 < 3; 索引二 = 索引二 + 1) {
        如果 (索引二 == 1) {
            下一层循环;  // 只跳过内层循环的当前迭代
        }
        控制台输出("i=" + 索引一 + ", j=" + 索引二);
    }
}
```

#### 使用注意事项

- `退出循环`和`下一层循环`只能用于for循环和while循环内部
- 在嵌套循环中，它们只影响当前层级的循环

## 成功样例代码示例

### Hello World示例 (hello.ch)
```ch
定义(空类型) 主函数() {
    控制台输出("Hello World!");
}
```

### 基础算术运算示例 (calculator.ch)
```ch
定义(空类型) 主函数() {
    定义(整型) 数值一 = 10;
    定义(整型) 数值二 = 20;
    定义(整型) 和 = 数值一 + 数值二;
    定义(整型) 积 = 数值一 * 数值二;
    控制台输出("a + b = " + 和);
    控制台输出("a * b = " + 积);
}
```

### 二进制运算符示例 (binary_operators.ch)
```ch
定义(空类型) 主函数() {
    控制台输出("=== 中文二进制运算符测试 ===");
    
    定义(整型) 数值一 = 12;  // 二进制: 1100
    定义(整型) 数值二 = 5;   // 二进制: 0101
    
    // 测试按位与运算符
    定义(整型) 按位与结果 = 数值一 & 数值二;
    控制台输出("按位与运算: ", 数值一, " & ", 数值二, " = ", 按位与结果);
    
    // 测试按位或运算符
    定义(整型) 按位或结果 = 数值一 | 数值二;
    控制台输出("按位或运算: ", 数值一, " | ", 数值二, " = ", 按位或结果);
    
    // 测试按位异或运算符
    定义(整型) 按位异或结果 = 数值一 ^ 数值二;
    控制台输出("按位异或运算: ", 数值一, " ^ ", 数值二, " = ", 按位异或结果);
}
```

### 逻辑运算符示例 (logic_operators.ch)
```ch
定义(空类型) 主函数() {
    控制台输出("=== 中文逻辑运算符测试 ===");
    
    定义(整型) 数值一 = 10;
    定义(整型) 数值二 = 20;
    
    // 测试"和"运算符
    如果 (数值一 > 5 和 数值二 < 30) {
        控制台输出("'和'条件满足: a > 5 且 b < 30");
    }
    
    // 测试"或"运算符
    如果 (数值一 == 5 或 数值二 == 20) {
        控制台输出("'或'条件满足: a == 5 或 b == 20");
    }
    
    控制台输出("中文逻辑运算符测试完成");
}
```

### 数组操作示例 (array_demo.ch)
```ch
定义(空类型) 主函数() {
    // 数组定义和初始化
    定义(整型) 数字数组[5];
    定义(整型) 索引 = 0;
    
    // 给数组赋值
    对于 (索引 = 0; 索引 < 5; 索引 = 索引 + 1) {
        数字数组[索引] = (索引 + 1) * 10;
    }
    
    // 输出数组内容
    控制台输出("数组内容:");
    控制台换行();
    对于 (索引 = 0; 索引 < 5; 索引 = 索引 + 1) {
        控制台输出("numbers[" + 索引 + "] = " + 数字数组[索引]);
        控制台换行();
    }
    
    // 数组计算
    定义(整型) 总和 = 0;
    对于 (索引 = 0; 索引 < 5; 索引 = 索引 + 1) {
        总和 = 总和 + 数字数组[索引];
    }
    控制台输出("数组总和: " + 总和);
    控制台换行();
}
```

### 条件语句示例 (conditions.ch)
```ch
定义(空类型) 主函数() {
    定义(整型) 分数 = 85;
    
    如果 (分数 >= 90) {
        控制台输出("成绩优秀");
    } 否则如果 (分数 >= 80) {
        控制台输出("成绩良好");
    } 否则如果 (分数 >= 70) {
        控制台输出("成绩中等");
    } 否则如果 (分数 >= 60) {
        控制台输出("成绩及格");
    } 否则 {
        控制台输出("成绩不及格");
    }
}
```

### 结构体示例 (struct_demo.ch)
```ch
定义(结构体) 学生 {
    字符串 姓名;
    整型 年龄;
    小数 成绩;
};

定义(空类型) 主函数() {
    定义(学生) 学生一;
    学生一.姓名 = "张三";
    学生一.年龄 = 18;
    学生一.成绩 = 95.5;
    
    控制台输出("学生信息:");
    控制台输出("姓名: ", 学生一.姓名);
    控制台输出("年龄: ", 学生一.年龄);
    控制台输出("成绩: ", 学生一.成绩);
}
```

### 逻辑运算符示例 (logic_operators.ch)
```ch
定义(空类型) 主函数() {
    定义(整型) 数值一 = 10;
    定义(整型) 数值二 = 20;
    
    控制台输出("=== 中文逻辑运算符测试 ===");
    
    // 逻辑与运算
    如果 (数值一 > 5 && 数值二 < 30) {
        控制台输出("'与'条件满足: 数值一 > 5 且 数值二 < 30");
    }
    
    // 逻辑或运算
    如果 (数值一 == 5 || 数值二 == 20) {
        控制台输出("'或'条件满足: 数值一 == 5 或 数值二 == 20");
    }
    
    // 逻辑非运算
    如果 (!(数值一 == 5)) {
        控制台输出("'非'条件满足: 数值一 不等于 5");
    }
    
    控制台输出("中文逻辑运算符测试完成");
}
```

### 类型转换示例 (type_conversion.ch)
```ch
定义(空类型) 主函数() {
    定义(整型) 整数值 = 10;
    定义(小数) 小数值 = 3.14;
    定义(字符串) 字符串值 = "100";
    
    // 隐式类型转换
    定义(小数) 结果一 = 整数值 + 小数值;  // 整型 + 小数 = 小数
    控制台输出("整型 + 小数 = ", 结果一);
    
    // 显式类型转换
    定义(整型) 结果二 = (整型)小数值;      // 小数转换为整型
    控制台输出("小数转换为整型: ", 结果二);
    
    // 字符串到数字的转换
    定义(整型) 结果三 = (整型)字符串值;    // 字符串转换为整型
    控制台输出("字符串转换为整型: ", 结果三);
}
```

## 问题排查与调试

### 常见错误及解决方法

1. **变量定义错误**: 确保变量定义时指定了正确的类型或使用空定义语法
2. **数组维度过大**: 检查数组大小是否超过系统限制（默认最大1000）
3. **导入文件错误**: 确保导入的文件路径正确且语法无误
4. **函数返回类型不匹配**: 检查函数定义和实际返回值的类型是否一致
5. **文件操作错误**: 确保文件路径正确且有相应的读写权限

### 调试技巧

- 使用 `chplus -d example.ch` 启用调试模式
- 检查错误信息中的行号定位问题
- 使用控制台输出语句进行变量跟踪
- 逐步测试代码片段以定位问题所在

## 贡献指南

欢迎提交bug报告和功能建议！请通过以下方式联系：
- Bug反馈: tg @abcdefgjha
- 功能建议: 提交issue或pull request

## 更新日志

### 最新更新
- 添加了25个样例文件测试结果
- 更新了README文档结构
- 完善了语法说明和示例代码

---
*最后更新: 2026年2月7日*
- 使用时需要确保逻辑正确，避免造成死循环
- 语句后必须以分号结束

### 文件内存存储

文件内存存储功能允许将程序中的变量持久化到文件中（默认为memory.txt），实现数据的跨程序共享和持久化。

#### 基本使用

```ch
// 使用文件内存存储执行程序
// 命令行: chplus -t example.ch
// 或保留内存文件: chplus -t reserve example.ch

定义(整型) 数值 = 100;
定义(字符串) 姓名 = "张三";
定义(小数) 圆周率 = 3.14159;
```

#### 功能特性

- **自动持久化**：启用文件内存存储后，所有变量自动保存到memory.txt文件
- **跨程序共享**：多个程序可以共享同一个memory.txt文件，实现数据传递
- **类型保持**：变量类型信息与值一同保存，确保数据完整性
- **自动清理**：默认情况下，程序执行结束后自动删除memory.txt文件
- **保留选项**：使用`-t reserve`参数可保留memory.txt文件供后续使用

#### 使用限制

文件内存存储功能存在以下技术限制：

- **变量个数限制**：理论上无硬性上限，实际受限于文件大小和系统内存
- **整型范围限制**：-2147483648 到 2147483647（32位有符号整数）
- **小数范围限制**：±1.7976931348623157E+308（IEEE 754双精度浮点数）
- **字符串长度限制**：单行建议不超过10000字符，受文件系统和内存限制
- **运算精度限制**：浮点数运算存在精度损失，大数运算可能溢出

#### 内存文件格式

memory.txt文件采用以下格式存储变量：

```
类型:变量名:值
```

示例：
```
整型:a:100
字符串:name:张三
小数:pi:3.14159
```

#### 使用场景

1. **数据持久化**：保存程序运行状态，下次运行时恢复
2. **程序间通信**：多个程序共享数据
3. **调试分析**：保留内存文件用于调试
4. **数据导出**：将程序数据导出为文本格式

### 纯内存存储

纯内存存储功能使用C++内存直接管理变量，不生成任何文件，性能更高且支持大数组。

#### 基本使用

```ch
// 使用纯内存存储执行程序
// 命令行: chplus -t memory example.ch

定义(整型) 数组[100000];
定义(整型) 索引;
对于 (索引 = 0; 索引 < 100000; 索引++) {
    数组[索引] = 索引 * 2;
}
```

#### 功能特性

- **高性能**：所有变量存储在C++内存中，访问速度极快
- **无文件IO**：不生成任何txt文件，减少磁盘IO开销
- **支持大数组**：不受1000个元素限制，支持超大数组
- **自动清理**：程序结束后自动释放所有内存，无需手动清理

#### 使用场景

1. **大数组处理**：需要处理超大数组时使用
2. **高性能计算**：需要最高性能时使用
3. **临时计算**：不需要持久化数据时使用
4. **内存密集型任务**：需要大量内存操作时使用

### 高精度整数计算

解释器内置BigInt高精度整数计算功能，支持任意长度的整数运算，不受传统整数类型限制。

#### 基本使用

```ch
// 超大整数运算
定义(整型) 数值一 = 12345678901234567890;
定义(整型) 数值二 = 98765432109876543210;

定义(整型) 和 = 数值一 + 数值二;
定义(整型) 差 = 数值一 - 数值二;
定义(整型) 积 = 数值一 * 数值二;
定义(整型) 商 = 数值一 / 数值二;
定义(整型) 模 = 数值一 % 数值二;
定义(整型) 幂 = 数值一 ^ 2;

控制台输出("a + b = " + 和);      // 111111111011111111100
控制台输出("a - b = " + 差);      // -86419753208641975320
控制台输出("a * b = " + 积);      // 1219326311370217952237463801111263526900
```

#### 支持的运算

- **基本运算**：`+`（加法）、`-`（减法）、`*`（乘法）、`/`（除法）、`%`（取模）
- **乘方运算**：`^`（乘方）
- **比较运算**：`==`、`!=`、`<`、`<=`、`>`、`>=`
- **复合赋值**：`+=`、`-=`、`*=`、`/=`、`%=`、`^=`
- **自增自减**：`++`、`--`（前缀和后置）
- **一元运算**：`-`（负号）

#### 功能特性

- **任意长度**：支持任意长度的整数运算，仅受系统内存限制
- **精确计算**：所有运算都是精确的整数运算，无精度损失
- **正负支持**：完全支持正数和负数运算
- **除零检查**：自动检测除零错误并给出友好提示
- **类型兼容**：与现有的整型类型完全兼容，无需修改代码

#### 使用场景

1. **大数计算**：需要处理超大整数时使用
2. **精确计算**：需要精确整数运算时使用
3. **密码学**：需要大数模运算时使用
4. **科学计算**：需要高精度整数运算时使用

#### 技术实现

- 使用自定义BigInt类实现大整数运算
- 基于vector存储数字，支持动态扩容
- 实现了完整的运算符重载
- 所有算术运算都使用BigInt进行计算

## 标准库

### 数学库 (math.ch)

- 三角函数：sin, cos, tan, asin, acos, atan
- 双曲函数：sinh, cosh, tanh
- 指数对数：exp, log, log10, sqrt, cbrt
- 取整函数：ceil, floor, round, trunc
- 绝对值：abs, fabs
- 其他函数：fmod, gcd, lcm
- 数学常量：PI, E, SQRT2

### 字符串库 (string.ch)

- 基础操作：长度、子串、查找、替换
- 转换功能：转大写、转小写、去空白
- 类型转换：整数转字符串、小数转字符串、布尔值转字符串
- 字符操作：获取字符、翻转、计数
- 高级功能：填充、分割、连接

### 文件库 (file.ch)

- 文件操作：文件写入、文件读取、文件追加、文件存在
- 文件重定向：重定向标准输出、恢复标准输出
- 文件系统：获取大小、路径操作
- 目录操作：创建、删除、重命名
- 文本处理：逐行读取、分割、合并

## 命令行选项

- `-a` : 自动格式化并覆盖原文件
- `-d 1` : 启用基本调试模式，显示基本的执行信息
- `-d 2` : 启用详细调试模式，显示详细的解析和执行步骤
- `-d 3` : 启用完整调试模式，显示所有执行信息、变量定义和变量大小
- `-t` : 使用文件内存存储（memory.txt），执行后自动删除
- `-t reserve` : 使用文件内存存储（memory.txt），执行后保留文件
- `-t memory` : 使用纯内存存储，不生成txt文件，支持大数组和高精度计算
- `-n, --no-format` : 不自动格式化代码
- `-h, --help` : 显示帮助信息

### 调试模式说明

解释器提供三个级别的调试模式，用于显示不同详细程度的执行信息：

#### 级别1：基本调试模式 (-d 1)

显示基本的执行流程信息，包括：
- 程序开始执行提示
- 全局语句处理信息
- 基本的调试输出

**适用场景**：快速了解程序执行流程，查看基本错误信息。

#### 级别2：详细调试模式 (-d 2)

显示详细的解析和执行步骤，包括：
- 解析器每条语句的解析过程
- 执行器每条语句的执行过程
- 语句类型的中文名称（如"变量定义"、"函数定义"、"控制台输出语句"等）
- 行号信息

**适用场景**：深入理解解析和执行过程，调试复杂的语法和逻辑问题。

#### 级别3：完整调试模式 (-d 3)

显示所有执行信息，包括级别2的所有内容，额外显示：
- 变量定义的详细信息：变量名、类型、大小、值
- 数组定义的详细信息：数组名、类型、维度、元素数量、元素大小、总大小
- 变量大小信息：
  - 整型：8字节
  - 小数：8字节
  - 布尔型：1字节
  - 字符型：1字节
  - 字符串：实际长度（字节）
  - 结构体：结构体
- 函数调用的参数值和返回值
- 表达式求值结果

**适用场景**：详细分析程序执行，查看变量内存使用情况，调试类型和内存问题。

#### 调试输出示例

```
[调试] 开始执行程序
[调试] 处理语句: 类型=函数定义, 行号=1
[执行器] 开始执行语句，类型=语句列表, 行号=1
[执行器] 执行语句列表
[执行器] 开始执行语句，类型=变量定义, 行号=2
[执行器] 执行变量定义
[调试3] 定义变量: a, 类型=整型, 大小=8字节, 值=10
[调试3] 定义变量: b, 类型=小数, 大小=8字节, 值=3.14
[调试3] 定义变量: c, 类型=布尔型, 大小=1字节, 值=真
[调试3] 定义变量: d, 类型=字符串, 大小=5字节, 值=hello
[调试3] 定义变量: e, 类型=字符型, 大小=1字节, 值=x
[调试3] 定义数组: arr1, 类型=整型, 维度=[5], 元素数量=5, 元素大小=8字节, 总大小=40字节
[调试3] 定义数组: arr2, 类型=小数, 维度=[3,2], 元素数量=6, 元素大小=8字节, 总大小=48字节
```

#### 类型名称说明

所有调试输出中的类型都使用可读的中文名称，不再显示数字：

- **语句类型**：函数定义、变量定义、控制台输出语句、控制台输入语句、如果语句、对于循环语句、当循环语句、退出循环语句、下一层循环语句等
- **数据类型**：整型、小数、布尔型、字符串、字符型、结构体
- **令牌类型**：定义、整型、字符串、如果、否则、控制台输出、退出循环、下一层循环、+、-、*、/等

**示例对比**：
- 旧版本：`类型=5`
- 新版本：`类型=变量定义`

## 许可证

原项目源库：[https://github.com/abcdefgjh-li/chplus]
