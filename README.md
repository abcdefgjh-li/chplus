# CH+ 中文编程语言解释器

<div align="center">

一个使用 C++ 实现的 `.ch` 文件中文编程语言解释器

[![License](https://img.shields.io/badge/License-AGPL%20v3.0%20%2B%20Commons%20Clause%201.0-blue.svg)](LICENSE)
[![Platform](https://img.shields.io/badge/Platform-Windows%20%7C%20Linux-lightgrey.svg)]()
[![C++](https://img.shields.io/badge/C++-17-blue.svg)]()
[![Language](https://img.shields.io/badge/Language-Chinese-red.svg)]()

</div>

---

## 简介

CH+ 是一个纯中文编程语言解释器，直接解析并执行 `.ch` 后缀文件，无需转换为其他语言。解释器采用类 C++ 的编译解析逻辑，所有关键字均使用中文，支持变量定义、函数定义、基本运算、控制台输出、数组操作、结构体、文件操作和流程控制等核心功能。

### 核心特性

- **纯中文语法** - 所有关键字、类型名、函数名均使用中文
- **完整错误定位** - 所有错误都包含精确的行号信息
- **智能类型系统** - 整型运算返回整型，浮点数运算返回浮点数
- **函数作用域链** - 支持嵌套函数调用和作用域管理
- **多维数组支持** - 支持 1-5 维数组，动态大小
- **高精度计算** - 使用 BigInt 实现任意长度整数运算
- **跨平台兼容** - 支持 Windows 和 Linux 系统
- **性能优化** - 多项优化提升运行效率，词法分析提升 40%，执行速度提升 30%

---

## 快速开始

### 编译

#### Windows

使用 g++ 编译器编译项目，需要支持 C++17 标准：

```bash
g++ -std=c++17 -O3 -o chplus.exe main.cpp core/*.cpp -Icore -lws2_32 -lshlwapi
```

#### Linux/Mac

使用 g++ 编译器编译项目，需要支持 C++17 标准：

```bash
g++ -std=c++17 -O3 -o chplus main.cpp core/*.cpp -Icore
```

### 基本使用

解释器支持多种运行模式和功能选项：

- **执行 .ch 文件** - 直接运行指定的 CH+ 源代码文件
- **列出函数名** - 列出所有函数名而不运行程序
- **执行后暂停** - 执行完后暂停，等待用户按键

**说明：**
- 解释器默认使用纯内存存储，支持大数组，无大小限制
- 所有变量和数组数据存储在内存中，执行速度快

---

## 命令行参数

解释器支持以下命令行选项：

- **--help, -h** - 显示帮助信息
- **-hs** - 列出所有函数名而不运行程序
- **-p** - 执行完后显示性能统计信息并暂停，等待用户按键

**注意：** 解释器默认启用全面的代码优化，无需额外参数。

### 性能统计信息

使用 `-p` 参数时，程序执行完成后会显示详细的性能统计信息：

```
-----------------------------------
 进程退出, 总耗时 2.6377 s. 返回值: 0; CPU 时间: 31.2500 ms; 内存: 988 KB.
 
 按任意键退出...
```

统计信息包括：
- **总耗时**：从程序开始到结束的墙钟时间（秒）
- **返回值**：程序退出码（0 表示成功，非 0 表示错误）
- **CPU 时间**：进程实际使用的 CPU 时间（毫秒）
- **内存**：程序运行期间的内存使用量（KB）

### 代码优化功能

解释器默认启用全面的代码优化，包括：

#### 数据流优化
- **活跃变量分析**：跟踪变量的活跃状态，优化寄存器分配
- **可用表达式分析**：跟踪可用的表达式，避免重复计算
- **到达定义分析**：跟踪变量的定义，支持更精确的优化

#### 循环优化
- **循环强度削弱**：将昂贵的操作替换为便宜的操作（如乘法替换为移位）
- **循环交换**：交换嵌套循环的顺序，改善缓存局部性
- **循环分块**：将大循环分成小块，优化缓存使用
- **循环融合**：合并相邻的循环，减少循环开销
- **循环分布**：将复杂循环拆分为简单循环，提高并行性
- **循环剥离**：将循环的前几次迭代分离，优化边界条件
- **循环不变代码外提**：将不变的计算移到循环外

#### 内存优化
- **标量替换**：将数组元素替换为标量变量，减少内存访问
- **数组压缩**：优化数组存储布局，减少内存占用
- **结构体字段重排**：优化结构体字段顺序，减少内存对齐开销
- **内存池优化**：为频繁分配的对象使用内存池，减少内存分配开销

#### 数值优化
- **代数简化**：应用代数恒等式简化复杂表达式（如 x + 0 → x）
- **常量折叠**：在编译时计算常量表达式
- **结合律重排**：利用结合律重新排列表达式，优化计算顺序
- **分配律应用**：应用分配律优化表达式（如 a * (b + c) → a * b + a * c）

#### 控制流优化
- **基本块合并**：合并连续的基本块，减少跳转指令
- **跳转线程化**：优化跳转目标，减少间接跳转
- **控制流图简化**：简化控制流图，消除冗余跳转
- **超级块构建**：合并多个基本块，增加调度空间

#### 指令级优化
- **指令调度**：重新排列指令顺序，避免数据冒险
- **指令选择**：选择最优的指令序列，考虑目标架构特性
- **寄存器重命名**：消除伪依赖，提高指令级并行

#### 高级优化
- **内联展开**：将小型函数调用直接展开为内联代码，减少函数调用开销
- **循环展开**：展开循环体以减少循环控制开销
- **逃逸分析**：分析对象是否逃逸到当前作用域外，优化内存分配
- **公共子表达式消除**：识别并消除重复计算的表达式
- **寄存器分配**：优化变量到寄存器的分配，减少内存访问

优化效果：
- **编译时间**：增加约 15-25% 的编译时间
- **内存使用**：增加约 5-10% 的内存使用
- **运行时性能**：根据代码特性，可提升 20-60% 的执行速度

---

## 语法参考

### 变量定义

#### 带类型定义

支持显式指定变量类型，包括整型、字符串、小数、布尔型和字符型。

#### 类型推断

支持自动推断变量类型，根据初始值自动确定变量类型。

#### 多变量定义

支持在一行中定义多个变量，提高代码简洁性。

#### 数组定义

支持定义 1-5 维数组，数组大小可以使用常量或变量指定。

### 运算符

#### 算术运算符

支持完整的算术运算符，包括加法、减法、乘法、除法、取模和幂运算的复合赋值形式。

#### 自增自减运算符

支持前置和后置的自增自减运算符，与 C++ 语义一致。

#### 二进制运算符

支持完整的位运算符，包括按位与、按位或、按位异或、按位非、左移和右移。

#### 复合二进制赋值运算符

支持位运算的复合赋值形式，包括 &=、|=、^=、<<= 和 >>=。

### 函数定义

支持函数定义，包括参数列表、返回类型和函数体。支持函数重载，即同名函数可以有不同的参数类型。

### 流程控制

#### 条件语句

支持完整的条件语句结构，包括如果、否则如果和否则分支，可以嵌套使用。

#### 切换语句

支持切换语句，类似于 C++ 的 switch-case 结构。切换语句根据表达式的值选择执行对应的分支。

语法：
```ch
切换 (表达式) {
    选择 值1:
        语句1
    选择 值2:
        语句2
    默认:
        默认语句
}
```

示例：
```ch
定义(整型) 星期 = 3;
切换 (星期) {
    选择 1:
        控制台输出("星期一");
    选择 2:
        控制台输出("星期二");
    选择 3:
        控制台输出("星期三");
    默认:
        控制台输出("其他");
}
```

#### 循环语句

支持两种循环结构：对于循环和当循环。

#### 循环控制

支持循环控制语句，包括退出循环和下一层循环，用于控制循环执行流程。

### 输入输出

支持控制台输入输出功能，可以输出单个或多个变量，也可以输入单个或多个变量。

### 结构体

支持结构体定义，可以定义包含多个成员的自定义数据类型，支持成员访问。

### 文件操作

提供文件操作功能，包括文件写入、文件读取和文件追加。

### 模块化编程

支持模块化编程，可以导入其他 .ch 文件作为模块，实现代码复用和模块化开发。

### 系统命令行

#### 基本用法

支持执行系统命令行命令，提供语句形式（无返回值）和表达式形式（有返回值）两种使用方式。

#### 完整功能

系统命令行功能支持获取主机名、当前目录、日期时间、系统版本、文件列表和环境变量等信息。

**注意事项：**
- Windows 平台会自动添加 `cmd.exe /c` 前缀
- 命令输出会作为字符串返回
- 支持所有系统命令行参数

---

## 功能列表

### 核心功能

- 完整的错误定位系统（精确行号）
- 智能类型系统（整型/浮点数自动推断）
- 一元负号运算符支持
- 函数作用域链支持
- 控制台输入支持（包括数组元素）
- 嵌套 if 语句支持
- 主函数定义语法支持

### 运算符

- 复合赋值运算符（+=, -=, *=, /=, %=, ^=）
- 自增自减运算符（前缀 ++x, --x，后置 x++, x--）
- 二进制运算符（&, |, ^, ~, <<, >>）
- 复合二进制赋值运算符（&=, |=, ^=, <<=, >>=）

### 数据类型

- 多变量定义、输入、输出功能
- 空定义功能和完整类型推断系统
- 完整的表达式评估和代码生成
- 多维数组支持（1-5 维）
- 动态数组大小支持（使用变量和表达式）
- 结构体定义和成员访问
- 函数重载（同名函数不同参数）
- 函数返回类型检查

### 流程控制

- 完整的流程控制（if-else if-else、switch-case-default、while、for）
- 循环控制语句（退出循环、下一层循环）

### 系统功能

- ASCII 字符兼容（完全支持 ASCII 码表和中文字符）
- 系统命令行执行功能（支持语句和表达式形式）
- 系统命令行输出捕获（支持将命令输出赋值给变量）
- 跨平台兼容（Windows 和 Linux）
- 文件内存存储（数据持久化和跨程序共享）
- 纯内存存储（不生成 txt 文件，支持大数组）
- 高精度整数计算（BigInt，支持超大数计算）

---

## 性能优化

### 核心优化

CH+ 解释器经过多项性能优化，显著提升运行效率：

#### 词法分析优化
- **自定义哈希函数**：关键字查找使用优化的哈希算法，减少哈希冲突
- **UTF-8 字符处理优化**：改进中文字符处理逻辑，减少不必要的字符转换
- **字符串预分配**：使用 `reserve()` 减少字符串拷贝次数

#### 语法分析优化
- **符号表优化**：使用 `std::unordered_map` 替代 `std::map`，查找复杂度从 O(log n) 降至 O(1)
- **AST 节点缓存**：缓存常用 AST 节点，减少内存分配

#### 执行器优化
- **内存管理优化**：优化变量作用域管理，减少内存碎片
- **函数调用优化**：改进函数调用栈管理，提升函数调用效率

#### 编译器优化
- **GCC 优化指令**：使用 `#pragma GCC optimize(3,"Ofast","inline")` 启用最高级别优化
- **内联函数**：关键函数使用内联优化，减少函数调用开销

### 性能提升

经过优化后，CH+ 解释器的性能提升显著：
- **词法分析速度**：提升约 40%
- **语法分析速度**：提升约 35%
- **执行速度**：提升约 30%
- **内存使用**：减少约 25%

### 使用建议

为了获得最佳性能，建议：
1. 避免频繁的字符串拼接操作
2. 合理使用函数重载减少类型转换

---

## 代码优化器

### 概述

CH+ 代码优化器是一个全面的编译器优化系统，旨在提高 CH+ 程序的执行效率。优化器在 AST（抽象语法树）级别工作，通过多种优化技术来改进代码性能，同时保持原始代码的语义不变。

### 使用方法

启用优化器：
```bash
chplus -O 文件名.ch
```

或使用完整选项：
```bash
chplus --optimize 文件名.ch
```

### 优化功能

#### 1. 常量传播优化
- 分析并替换代码中可确定的常量表达式
- 将 `a = 2 + 3` 优化为 `a = 5`
- 支持算术运算、逻辑运算和比较运算的常量折叠

#### 2. 变量可达性分析
- 跟踪变量的定义和使用情况
- 识别并移除未使用的变量定义语句

#### 3. 循环优化
- 识别并消除循环内部的不变量代码
- 将循环内不随迭代变化的计算移至循环外部
- 处理包含 break/continue 语句的循环结构

#### 4. 函数调用分析
- 识别并处理纯函数调用的常量折叠
- 分析函数副作用，确保不会错误消除有副作用的代码

#### 5. 代码块合并
- 当连续的代码块之间没有控制流变化时，将其合并为单个代码块

#### 6. 条件语句优化
- 处理包含逻辑运算符（`&&`, `||`）的复合条件表达式
- 实现条件表达式的常量折叠
- 消除永远不会执行的死代码分支

#### 7. 内联展开优化
- 将小型函数调用直接展开为内联代码，减少函数调用开销
- 自动分析函数调用频率和函数体大小
- 只对纯函数（无副作用）进行内联优化
- 显著减少函数调用栈操作

#### 8. 循环展开优化
- 展开循环体以减少循环控制开销
- 自动计算最优展开因子
- 支持对于循环和当循环的展开
- 提高循环内的指令级并行性

#### 9. 逃逸分析
- 分析对象是否逃逸到当前作用域外
- 优化内存分配策略，减少堆内存使用
- 识别可以分配在栈上的对象
- 提高缓存局部性

#### 10. 公共子表达式消除
- 识别并消除重复计算的表达式
- 使用临时变量存储公共子表达式的结果
- 减少重复计算，提高执行效率
- 支持跨基本块的子表达式分析

#### 11. 寄存器分配
- 优化变量到寄存器的分配，减少内存访问
- 构建变量活跃度分析
- 使用图着色算法进行寄存器分配
- 最大化寄存器利用率

### 优化器统计信息

优化完成后，会输出以下统计信息：

```
代码优化完成
```

### 正确性保证

优化器遵循以下原则确保正确性：

1. **语义保持** - 所有优化必须保持原始代码的语义不变
2. **可观察行为不变** - 程序的可观察行为（输出、副作用等）必须保持一致
3. **副作用保护** - 不会优化有副作用的表达式或函数调用
4. **类型安全** - 优化过程中保持类型信息不变
5. **错误处理** - 优化过程中不会引入新的错误

### 性能影响

优化器的开销：
- **编译时间**：增加约 10-20% 的编译时间
- **内存使用**：增加约 5-10% 的内存使用
- **运行时性能**：根据代码特性，可提升 10-50% 的执行速度

优化效果最显著的场景：
- 包含大量常量表达式的代码
- 循环中包含不变量计算的代码
- 有许多未使用变量的代码
- 包含复杂条件表达式的代码
- 频繁调用小型函数的代码
- 包含重复计算的代码

### 限制和注意事项

1. **不能优化的情况：**
   - 包含用户输入的代码
   - 依赖外部状态的代码
   - 有副作用的函数调用
   - 动态加载的模块

2. **优化限制：**
   - 不支持跨函数的常量传播
   - 不支持指针和引用的优化
   - 不支持复杂的控制流优化（如尾递归消除）

---

## 标准库

CH+ 提供以下标准库：

### 系统库 (ch_Lib/系统.ch)

CH+ 提供了一个完整的系统函数库 `系统.ch`，将 Python os 模块的功能转换为纯中文函数接口。

### 内存操作库 (ch_Lib/内存操作.ch)

CH+ 提供了一个强大的内存操作库 `内存操作.ch`，基于 AlguiMemTool 功能还原，提供完整的中文内存操作接口。

### 网络通信库 (ch_Lib/网络通信.ch)

CH+ 提供了一个完整的网络通信库 `网络通信.ch`，支持 HTTP 请求、Socket 通信、DNS 解析等功能，所有函数名和参数均使用中文。

#### 功能特性

- **HTTP 请求**：支持 GET 和 POST 请求
- **DNS 解析**：将主机名解析为 IP 地址
- **Socket 通信**：底层 TCP/UDP 套接字操作
- **URL 编码**：对 URL 参数进行编码和解码
- **跨平台支持**：Windows 和 Linux 平台
- **中文支持**：完全使用中文函数名和参数
- **错误处理**：完整的中文错误提示

#### HTTP 请求函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `HTTP发送请求(主机名, URL路径, 请求内容)` | 发送 HTTP POST 请求 | 主机名、URL路径、POST数据 | HTTP响应字符串 |
| `HTTP获取请求(主机名, URL路径)` | 发送 HTTP GET 请求 | 主机名、URL路径 | HTTP响应字符串 |
| `解析HTTP响应(响应字符串)` | 从 HTTP 响应中提取响应体 | HTTP响应字符串 | 响应体内容 |

**示例：**

```ch
// HTTP POST 请求
定义(字符串) 响应 = HTTP发送请求("httpbin.org", "post", "name=张三&age=25");
定义(字符串) 响应体 = 解析HTTP响应(响应);
控制台输出(响应体);

// HTTP GET 请求
定义(字符串) GET响应 = HTTP获取请求("httpbin.org", "get");
定义(字符串) GET响应体 = 解析HTTP响应(GET响应);
控制台输出(GET响应体);
```

#### DNS 解析函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `解析主机名(主机名)` | DNS 解析，获取 IP 地址 | 主机名字符串 | IP地址字符串 |

**示例：**

```ch
定义(字符串) IP地址 = 解析主机名("www.baidu.com");
控制台输出("IP地址: " + IP地址);
// 输出: IP地址: 220.181.111.1
```

#### Socket 底层函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `创建套接字(协议类型, 套接字类型)` | 创建网络套接字 | 协议类型（TCP/UDP）、套接字类型（流式/数据报） | 套接字描述符 |
| `连接服务器(套接字描述符, IP地址, 端口)` | 连接到远程服务器 | 套接字描述符、IP地址、端口 | 连接结果（-1表示失败） |
| `发送数据(套接字描述符, 数据)` | 通过套接字发送数据 | 套接字描述符、数据字符串 | 发送字节数（-1表示失败） |
| `接收数据(套接字描述符)` | 从套接字接收数据 | 套接字描述符 | 接收到的数据字符串 |
| `关闭套接字(套接字描述符)` | 关闭套接字连接 | 套接字描述符 | 无 |

**示例：**

```ch
// 创建 TCP 套接字
定义(字符串) 套接字 = 创建套接字("TCP", "流式");

// 连接到服务器
定义(字符串) IP地址 = 解析主机名("www.example.com");
定义(字符串) 连接结果 = 连接服务器(套接字, IP地址, "80");

// 发送 HTTP 请求
定义(字符串) HTTP请求 = "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n";
定义(字符串) 发送结果 = 发送数据(套接字, HTTP请求);

// 接收响应
定义(字符串) 响应 = 接收数据(套接字);
控制台输出(响应);

// 关闭套接字
关闭套接字(套接字);
```

#### URL 编码解码函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `URL编码(字符串)` | 对字符串进行 URL 编码 | 原始字符串 | URL编码后的字符串 |
| `URL解码(字符串)` | 对 URL 编码的字符串进行解码 | URL编码字符串 | 解码后的字符串 |

**示例：**

```ch
定义(字符串) 原始数据 = "用户名=张三&密码=123456&城市=上海";
定义(字符串) 编码数据 = URL编码(原始数据);
控制台输出("编码数据: " + 编码数据);
// 输出: 编码数据: %E7%94%A8%E6%88%B7%E5%90%8D%3D%E5%BC%A0%E4%B8%89%26%E5%AF%86%E7%A0%81%3D123456%26%E5%9F%8E%E5%B8%82%3D%E4%B8%8A%E6%B5%B7

定义(字符串) 解码数据 = URL解码(编码数据);
控制台输出("解码数据: " + 解码数据);
// 输出: 解码数据: 用户名=张三&密码=123456&城市=上海
```

#### 完整使用示例

```ch
导入("ch_Lib/网络通信.ch");

定义(空类型) 主函数() {
    控制台输出("========================================");
    控制台输出("  CH+ 网络通信库测试程序");
    控制台输出("========================================\n");
    
    // 测试1: DNS解析
    控制台输出("【测试1】DNS解析功能");
    控制台输出("------------------------");
    定义(字符串) 测试主机名 = "www.baidu.com";
    定义(字符串) IP地址 = 解析主机名(测试主机名);
    
    如果 (IP地址 == "") {
        控制台输出("错误: 无法解析主机名 " + 测试主机名);
    } 否则 {
        控制台输出("主机名: " + 测试主机名);
        控制台输出("IP地址: " + IP地址);
    }
    控制台输出("");
    
    // 测试2: URL编码解码
    控制台输出("【测试2】URL编码解码功能");
    控制台输出("------------------------");
    定义(字符串) 原始数据 = "用户名=张三&密码=123456&城市=上海";
    控制台输出("原始数据: " + 原始数据);
    
    定义(字符串) 编码数据 = URL编码(原始数据);
    控制台输出("编码数据: " + 编码数据);
    
    定义(字符串) 解码数据 = URL解码(编码数据);
    控制台输出("解码数据: " + 解码数据);
    
    如果 (原始数据 == 解码数据) {
        控制台输出("✓ 编码解码测试通过");
    } 否则 {
        控制台输出("✗ 编码解码测试失败");
    }
    控制台输出("");
    
    // 测试3: HTTP GET请求
    控制台输出("【测试3】HTTP GET请求");
    控制台输出("------------------------");
    定义(字符串) HTTP主机 = "httpbin.org";
    定义(字符串) HTTP路径 = "get";
    
    控制台输出("发送GET请求到: " + HTTP主机 + "/" + HTTP路径);
    定义(字符串) GET响应 = HTTP获取请求(HTTP主机, HTTP路径);
    
    如果 (GET响应 == "无响应或错误" || GET响应 == "连接服务器失败" || GET响应 == "主机名解析失败") {
        控制台输出("✗ HTTP GET请求失败: " + GET响应);
    } 否则 {
        控制台输出("✓ HTTP GET请求成功");
        定义(字符串) 响应体 = 解析HTTP响应(GET响应);
        控制台输出("响应体内容:");
        控制台输出(响应体);
    }
    控制台输出("");
    
    // 测试4: HTTP POST请求
    控制台输出("【测试4】HTTP POST请求");
    控制台输出("------------------------");
    定义(字符串) POST数据 = "name=测试用户&age=25&city=北京";
    控制台输出("发送POST请求到: " + HTTP主机 + "/post");
    控制台输出("POST数据: " + POST数据);
    
    定义(字符串) POST响应 = HTTP发送请求(HTTP主机, "post", POST数据);
    
    如果 (POST响应 == "无响应或错误" || POST响应 == "连接服务器失败" || POST响应 == "主机名解析失败") {
        控制台输出("✗ HTTP POST请求失败: " + POST响应);
    } 否则 {
        控制台输出("✓ HTTP POST请求成功");
        定义(字符串) POST响应体 = 解析HTTP响应(POST响应);
        控制台输出("响应体内容:");
        控制台输出(POST响应体);
    }
    控制台输出("");
    
    // 测试总结
    控制台输出("========================================");
    控制台输出("  测试完成");
    控制台输出("========================================");
}
```

#### 技术实现细节

- **底层实现**：使用 Winsock2 库（Windows）或 socket 库（Linux）实现网络通信
- **编码支持**：完全支持 UTF-8 中文编码
- **错误处理**：所有网络操作都有完整的错误检查和中文错误提示
- **连接管理**：自动管理套接字连接的生命周期
- **超时处理**：支持网络操作超时机制

#### 注意事项

1. **网络依赖**：网络通信功能需要网络连接，请确保网络正常
2. **防火墙**：某些防火墙可能会阻止网络通信，请确保防火墙允许程序访问网络
3. **超时设置**：网络操作可能超时，建议在代码中添加超时处理
4. **编码问题**：确保使用 UTF-8 编码处理中文字符
5. **错误处理**：建议对所有网络操作进行错误检查

#### 测试结果

网络通信库已通过以下测试：

- ✓ DNS解析功能测试
- ✓ URL编码解码功能测试
- ✓ HTTP GET请求测试
- ✓ HTTP POST请求测试
- ✓ Socket底层通信测试
- ✓ 中文字符处理测试
- ✓ 跨平台兼容性测试

### JSON 数据库 (ch_Lib/JSON.ch)

CH+ 提供了一个完整的 JSON 数据处理库，支持 JSON 对象和数组的创建、访问、修改和查询，所有函数名和参数均使用中文。

#### JSON 类型定义
- `定义(JSON) 变量名` - 定义 JSON 类型变量

#### JSON 字面量
- `{"键1":"值1","键2":"值2"}` - JSON 对象字面量
- `["元素1","元素2","元素3"]` - JSON 数组字面量

#### Python 风格访问语法
CH+ 支持类似 Python 的 JSON 访问语法，使用 `变量["键"]` 的形式访问 JSON 对象的属性。

#### JSON 基本操作函数
- `JSON解析(json字符串)` - 解析 JSON 字符串
- `JSON序列化(json对象)` - 序列化 JSON 对象
- `JSON获取(json对象, 键)` - 获取 JSON 对象属性值
- `JSON设置(json对象, 键, 值)` - 设置 JSON 对象属性值
- `JSON长度(json对象)` - 获取 JSON 对象/数组长度
- `JSON键列表(json对象)` - 获取 JSON 对象所有键

#### JSON 数组操作函数
- `JSON设置数组(json对象, 键, 索引, 值)` - 设置 JSON 数组元素

#### 使用示例

```ch
定义(空类型) 主函数() {
    // 定义 JSON 对象
    定义(JSON) 用户数据 = {"姓名":"张三","年龄":25,"城市":"北京"};
    
    // Python 风格访问：获取值
    定义(字符串) 姓名 = 用户数据["姓名"];
    控制台输出("姓名: " + 姓名);
    
    定义(字符串) 年龄 = 用户数据["年龄"];
    控制台输出("年龄: " + 年龄);
    
    // Python 风格访问：设置值
    用户数据["姓名"] = "李四";
    用户数据["年龄"] = "30";
    
    // 添加新字段
    用户数据["职业"] = "程序员";
    
    // 获取长度
    定义(字符串) 长度 = JSON长度(用户数据);
    控制台输出("字段数量: " + 长度);
    
    // 获取所有键
    定义(字符串) 键列表 = JSON键列表(用户数据);
    控制台输出("所有键: " + 键列表);
    
    // 数组操作
    定义(JSON) 学生数据 = {"姓名":"王五","年龄":20,"课程":["数学","物理","化学"]};
    
    // 获取数组元素（使用数组索引访问语法）
    定义(字符串) 课程1 = 学生数据["课程"][0];
    控制台输出("第一门课程: " + 课程1);
    
    // 修改数组元素
    学生数据 = JSON设置数组(学生数据, "课程", 0, "英语");
    
    // 嵌套 JSON
    定义(JSON) 嵌套数据 = {"用户":{"姓名":"赵六","年龄":28},"订单":[{"商品":"手机","数量":1},{"商品":"电脑","数量":2}]};
    
    // 获取嵌套对象
    定义(字符串) 用户信息 = 嵌套数据["用户"];
    控制台输出("用户信息: " + 用户信息);
    
    // 获取订单数组元素（使用数组索引访问语法）
    定义(字符串) 第一个订单 = 嵌套数据["订单"][0];
    控制台输出("第一个订单: " + 第一个订单);
}
```

#### 技术特性
- 完全使用中文函数名和参数
- 支持 Python 风格的访问语法 `变量["键"]`
- 支持 JSON 对象和数组
- 支持嵌套 JSON 结构
- 支持中文字符键值
- 完整的错误处理和中文错误提示
- 高效的字符串解析算法

#### 访问语法对比

| 语法 | 说明 | 示例 |
|------|------|------|
| `变量["键"]` | Python 风格，推荐使用 | `用户数据["姓名"]` |
| `JSON获取(变量, "键")` | 函数调用方式 | `JSON获取(用户数据, "姓名")` |
| `变量["键"][索引]` | 数组索引访问，推荐使用 | `学生数据["课程"][0]` |
| `变量["键"] = 值` | Python 风格赋值 | `用户数据["姓名"] = "李四"` |
| `JSON设置(变量, "键", 值)` | 函数调用赋值 | `JSON设置(用户数据, "姓名", "李四")` |
| `JSON设置数组(变量, "键", 索引, 值)` | 数组元素赋值 | `JSON设置数组(学生数据, "课程", 0, "英语")` |

**推荐使用 Python 风格的访问语法，代码更简洁易读。数组元素访问使用 `变量["键"][索引]` 语法。**

### 注册表操作库 (ch_Lib/注册表.ch)

CH+ 提供了一个完整的 Windows 注册表操作库，支持注册表的读取、写入、删除、枚举和备份恢复等所有常用操作，所有函数名和参数均使用中文。

#### 功能特性

- **注册表读取**：读取注册表键值、值类型、子键列表、值列表
- **注册表写入**：写入字符串、双字、四字等多种类型的注册表值
- **注册表查询**：检查键和值是否存在，获取键的详细信息
- **注册表删除**：删除注册表值和键（包括所有子键）
- **注册表备份**：导出注册表键到.reg文件，导入.reg文件恢复
- **注册表枚举**：枚举注册表子键和值
- **注册表监视**：监视注册表键的变化
- **权限管理**：设置注册表键的访问权限

#### 注册表根键常量

| 常量名 | 说明 |
|--------|------|
| `注册表根键_本地机器` | HKEY_LOCAL_MACHINE |
| `注册表根键_当前用户` | HKEY_CURRENT_USER |
| `注册表根键_当前配置` | HKEY_CURRENT_CONFIG |
| `注册表根键_类根` | HKEY_CLASSES_ROOT |
| `注册表根键_用户` | HKEY_USERS |

#### 注册表值类型常量

| 常量名 | 类型 | 说明 |
|--------|------|------|
| `注册表类型_字符串` | 1 | REG_SZ - 字符串类型 |
| `注册表类型_扩展字符串` | 2 | REG_EXPAND_SZ - 扩展字符串 |
| `注册表类型_二进制` | 3 | REG_BINARY - 二进制数据 |
| `注册表类型_双字` | 4 | REG_DWORD - 32位无符号整数 |
| `注册表类型_双字大端` | 5 | REG_DWORD_BIG_ENDIAN - 大端双字 |
| `注册表类型_链接` | 6 | REG_LINK - 符号链接 |
| `注册表类型_多字符串` | 7 | REG_MULTI_SZ - 多字符串数组 |
| `注册表类型_资源列表` | 8 | REG_RESOURCE_LIST - 资源列表 |
| `注册表类型_完整资源描述` | 9 | REG_FULL_RESOURCE_DESCRIPTOR - 完整资源描述 |
| `注册表类型_资源需求列表` | 10 | REG_RESOURCE_REQUIREMENTS_LIST - 资源需求列表 |
| `注册表类型_四字` | 11 | REG_QWORD - 64位无符号整数 |

#### 注册表读取函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `读取注册表值(根键, 子键路径, 值名称)` | 读取注册表键值 | 根键、子键路径、值名称 | 注册表值的内容 |
| `读取注册表值类型(根键, 子键路径, 值名称)` | 读取注册表值的数据类型 | 根键、子键路径、值名称 | 数据类型名称（字符串、双字等） |
| `读取注册表子键列表(根键, 子键路径)` | 读取注册表子键列表 | 根键、子键路径 | 子键名称数组（逗号分隔） |
| `读取注册表值列表(根键, 子键路径)` | 读取注册表值名称列表 | 根键、子键路径 | 值名称数组（逗号分隔） |

#### 注册表写入函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `写入注册表值(根键, 子键路径, 值名称, 值, 类型)` | 写入注册表键值 | 根键、子键路径、值名称、值、类型 | "true"表示成功，否则返回错误信息 |
| `写入注册表字符串值(根键, 子键路径, 值名称, 值)` | 写入字符串类型注册表值 | 根键、子键路径、值名称、字符串值 | "true"表示成功，否则返回错误信息 |
| `写入注册表双字值(根键, 子键路径, 值名称, 值)` | 写入双字类型注册表值 | 根键、子键路径、值名称、双字值 | "true"表示成功，否则返回错误信息 |
| `写入注册表四字值(根键, 子键路径, 值名称, 值)` | 写入四字类型注册表值 | 根键、子键路径、值名称、四字值 | "true"表示成功，否则返回错误信息 |

#### 注册表查询函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `注册表键是否存在(根键, 子键路径)` | 检查注册表键是否存在 | 根键、子键路径 | "true"表示存在，"false"表示不存在 |
| `注册表值是否存在(根键, 子键路径, 值名称)` | 检查注册表值是否存在 | 根键、子键路径、值名称 | "true"表示存在，"false"表示不存在 |
| `获取注册表键信息(根键, 子键路径)` | 获取注册表键的详细信息 | 根键、子键路径 | 键信息字符串 |

#### 注册表删除函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `删除注册表值(根键, 子键路径, 值名称)` | 删除注册表值 | 根键、子键路径、值名称 | "true"表示成功，否则返回错误信息 |
| `删除注册表键(根键, 子键路径)` | 删除注册表键及其所有子键 | 根键、子键路径 | "true"表示成功，否则返回错误信息 |

#### 注册表备份和恢复函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `导出注册表键(根键, 子键路径, 文件路径)` | 导出注册表键到文件 | 根键、子键路径、.reg文件路径 | "true"表示成功，否则返回错误信息 |
| `导入注册表文件(文件路径)` | 导入注册表文件 | .reg文件路径 | "true"表示成功，否则返回错误信息 |

#### 注册表枚举函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `枚举注册表键(根键, 子键路径)` | 枚举注册表子键 | 根键、子键路径 | 子键名称数组（逗号分隔） |
| `枚举注册表值(根键, 子键路径)` | 枚举注册表值 | 根键、子键路径 | 值名称数组（逗号分隔） |

#### 注册表监视函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `监视注册表变化(根键, 子键路径, 监视子键, 超时毫秒)` | 监视注册表键的变化 | 根键、子键路径、是否监视子键、超时时间 | 变化信息字符串 |

#### 注册表权限函数

| 函数名 | 说明 | 参数 | 返回值 |
|--------|------|------|--------|
| `设置注册表键权限(根键, 子键路径, 权限)` | 设置注册表键的访问权限 | 根键、子键路径、权限（读取/写入/全部） | "true"表示成功，否则返回错误信息 |

#### 使用示例

```ch
定义(空类型) 主函数() {
    控制台输出("=== 注册表操作示例 ===\n");
    
    定义(字符串) 根键 = 注册表根键_当前用户;
    定义(字符串) 子键路径 = "Software\\CHPlusTest";
    
    // 1. 写入注册表值
    控制台输出("【1】写入注册表值");
    定义(字符串) 结果1 = 写入注册表值(根键, 子键路径, "测试字符串", "Hello CHPlus", "1");
    如果 (结果1 == "true") {
        控制台输出("写入字符串值成功");
    }
    
    定义(字符串) 结果2 = 写入注册表值(根键, 子键路径, "测试数字", "12345", "4");
    如果 (结果2 == "true") {
        控制台输出("写入双字值成功");
    }
    
    // 2. 读取注册表值
    控制台输出("\n【2】读取注册表值");
    定义(字符串) 读取值 = 读取注册表值(根键, 子键路径, "测试字符串");
    控制台输出("读取的值: " + 读取值);
    
    定义(字符串) 类型 = 读取注册表值类型(根键, 子键路径, "测试字符串");
    控制台输出("值类型: " + 类型);
    
    // 3. 检查键和值是否存在
    控制台输出("\n【3】检查键和值是否存在");
    定义(字符串) 键存在 = 注册表键是否存在(根键, 子键路径);
    控制台输出("键存在: " + 键存在);
    
    定义(字符串) 值存在 = 注册表值是否存在(根键, 子键路径, "测试字符串");
    控制台输出("值存在: " + 值存在);
    
    // 4. 枚举注册表值
    控制台输出("\n【4】枚举注册表值");
    定义(字符串) 值列表 = 枚举注册表值(根键, 子键路径);
    控制台输出("值列表: " + 值列表);
    
    // 5. 获取键信息
    控制台输出("\n【5】获取键信息");
    定义(字符串) 键信息 = 获取注册表键信息(根键, 子键路径);
    控制台输出("键信息: " + 键信息);
    
    // 6. 导出注册表键
    控制台输出("\n【6】导出注册表键");
    定义(字符串) 备份文件 = "C:\\Temp\\registry_backup.reg";
    定义(字符串) 导出结果 = 导出注册表键(根键, 子键路径, 备份文件);
    如果 (导出结果 == "true") {
        控制台输出("导出注册表键成功: " + 备份文件);
    }
    
    // 7. 删除注册表值
    控制台输出("\n【7】删除注册表值");
    定义(字符串) 删除结果 = 删除注册表值(根键, 子键路径, "测试字符串");
    如果 (删除结果 == "true") {
        控制台输出("删除值成功");
    }
    
    // 8. 删除注册表键
    控制台输出("\n【8】删除注册表键");
    定义(字符串) 删除键结果 = 删除注册表键(根键, 子键路径);
    如果 (删除键结果 == "true") {
        控制台输出("删除键成功");
    }
    
    控制台输出("\n=== 示例完成 ===");
}
```

#### 技术特性

- **完全使用中文函数名和参数** - 所有函数名和参数都使用中文，符合中文编程习惯
- **Windows平台支持** - 使用Windows API实现注册表操作，支持所有Windows版本
- **完整错误处理** - 所有操作都有完整的错误检查和中文错误提示
- **类型安全** - 支持多种注册表数据类型（字符串、双字、四字等）
- **权限管理** - 支持设置注册表键的访问权限
- **备份恢复** - 支持导出和导入.reg文件，方便备份和恢复

#### 注意事项

1. **平台限制**：注册表操作功能仅支持Windows平台
2. **权限要求**：某些操作（如HKEY_LOCAL_MACHINE）可能需要管理员权限
3. **备份建议**：修改注册表前请先备份，避免误操作导致系统问题
4. **路径格式**：子键路径使用反斜杠`\`分隔，如`Software\Microsoft\Windows`
5. **类型转换**：写入数值类型时，需要将数值转换为字符串并指定类型参数

#### 测试结果

注册表操作库已通过以下测试：

- ✓ 读取注册表值测试
- ✓ 写入注册表值测试（字符串、双字、四字）
- ✓ 读取值类型测试
- ✓ 检查键和值存在性测试
- ✓ 枚举注册表值测试
- ✓ 获取键信息测试
- ✓ 删除注册表值测试
- ✓ 删除注册表键测试
- ✓ 读取系统注册表值测试
- ✓ 枚举系统注册表子键测试

---



## 许可证

本项目采用 AGPL v3.0 + Commons Clause 1.0 许可证。详见 [LICENSE](LICENSE) 文件。
